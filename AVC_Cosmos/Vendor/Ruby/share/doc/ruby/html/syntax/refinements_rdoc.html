<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>refinements - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/darkfish.js"></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Refinements">Refinements</a>
    <li><a href="#label-Scope">Scope</a>
    <li><a href="#label-Method+Lookup">Method Lookup</a>
    <li><a href="#label-super"><code>super</code></a>
    <li><a href="#label-Indirect+Method+Calls">Indirect Method Calls</a>
    <li><a href="#label-Further+Reading">Further Reading</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../README_ja_md.html">README.ja</a>
  
    <li><a href="../README_md.html">README</a>
  
    <li><a href="../contributing_rdoc.html">contributing</a>
  
    <li><a href="../contributors_rdoc.html">contributors</a>
  
    <li><a href="../dtrace_probes_rdoc.html">dtrace_probes</a>
  
    <li><a href="../extension_ja_rdoc.html">extension.ja</a>
  
    <li><a href="../extension_rdoc.html">extension</a>
  
    <li><a href="../globals_rdoc.html">globals</a>
  
    <li><a href="../keywords_rdoc.html">keywords</a>
  
    <li><a href="../lib/racc/rdoc/grammar_en_rdoc.html">grammar.en</a>
  
    <li><a href="../lib/rubygems/LICENSE_txt.html">LICENSE</a>
  
    <li><a href="../maintainers_rdoc.html">maintainers</a>
  
    <li><a href="../marshal_rdoc.html">marshal</a>
  
    <li><a href="../regexp_rdoc.html">regexp</a>
  
    <li><a href="../security_rdoc.html">security</a>
  
    <li><a href="../standard_library_rdoc.html">standard_library</a>
  
    <li><a href="../syntax_rdoc.html">syntax</a>
  
    <li><a href="../syntax/assignment_rdoc.html">assignment</a>
  
    <li><a href="../syntax/calling_methods_rdoc.html">calling_methods</a>
  
    <li><a href="../syntax/control_expressions_rdoc.html">control_expressions</a>
  
    <li><a href="../syntax/exceptions_rdoc.html">exceptions</a>
  
    <li><a href="../syntax/literals_rdoc.html">literals</a>
  
    <li><a href="../syntax/methods_rdoc.html">methods</a>
  
    <li><a href="../syntax/miscellaneous_rdoc.html">miscellaneous</a>
  
    <li><a href="../syntax/modules_and_classes_rdoc.html">modules_and_classes</a>
  
    <li><a href="../syntax/precedence_rdoc.html">precedence</a>
  
    <li><a href="../syntax/refinements_rdoc.html">refinements</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page syntax/refinements.rdoc">

<h1 id="label-Refinements">Refinements<span><a href="#label-Refinements">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>Due to Ruby&#39;s open classes you can redefine or add functionality to
existing classes.  This is called a “monkey patch”.  Unfortunately the
scope of such changes is global.  All users of the monkey-patched class see
the same changes.  This can cause unintended side-effects or breakage of
programs.</p>

<p>Refinements are designed to reduce the impact of monkey patching on other
users of the monkey-patched class.  Refinements provide a way to extend a
class locally.</p>

<p>Here is a basic refinement:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">foo</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;C#foo&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">module</span> <span class="ruby-constant">M</span>
  <span class="ruby-identifier">refine</span> <span class="ruby-constant">C</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">foo</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;C#foo in M&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>First, a class <code>C</code> is defined.  Next a refinement for
<code>C</code> is created using <a
href="../Module.html#method-i-refine">Module#refine</a>.  Refinements only
modify classes, not modules so the argument must be a class.</p>

<p><a href="../Module.html#method-i-refine">Module#refine</a> creates an
anonymous module that contains the changes or refinements to the class
(<code>C</code> in the example).  <code>self</code> in the refine block is
this anonymous module similar to <a
href="../Module.html#method-i-module_eval">Module#module_eval</a>.</p>

<p>Activate the refinement with using:</p>

<pre class="ruby"><span class="ruby-identifier">using</span> <span class="ruby-constant">M</span>

<span class="ruby-identifier">c</span> = <span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>

<span class="ruby-identifier">c</span>.<span class="ruby-identifier">foo</span> <span class="ruby-comment"># prints &quot;C#foo in M&quot;</span>
</pre>

<h2 id="label-Scope">Scope<span><a href="#label-Scope">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You may activate refinements at top-level, and inside classes and modules.
You may not activate refinements in method scope.  Refinements are
activated until the end of the current class or module definition, or until
the end of the current file if used at the top-level.</p>

<p>You may activate refinements in a string passed to <a
href="../Kernel.html#method-i-eval">Kernel#eval</a>. Refinements are active
the end of the eval string.</p>

<p>Refinements are lexical in scope.  Refinements are only active within a
scope after the call to using. Any code before the using statement will not
have the refinement activated.</p>

<p>When control is transferred outside the scope the refinement is
deactivated. This means that if you require or load a file or call a method
that is defined outside the current scope the refinement will be
deactivated:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">module</span> <span class="ruby-constant">M</span>
  <span class="ruby-identifier">refine</span> <span class="ruby-constant">C</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">foo</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;C#foo in M&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier">call_foo</span>(<span class="ruby-identifier">x</span>)
  <span class="ruby-identifier">x</span>.<span class="ruby-identifier">foo</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">using</span> <span class="ruby-constant">M</span>

<span class="ruby-identifier">x</span> = <span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">x</span>.<span class="ruby-identifier">foo</span>       <span class="ruby-comment"># prints &quot;C#foo in M&quot;</span>
<span class="ruby-identifier">call_foo</span>(<span class="ruby-identifier">x</span>) <span class="ruby-comment">#=&gt; raises NoMethodError</span>
</pre>

<p>If a method is defined in a scope where a refinement is active the
refinement will be active when the method is called.  This example spans
multiple files:</p>

<p>c.rb:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
<span class="ruby-keyword">end</span>
</pre>

<p>m.rb:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;c&quot;</span>

<span class="ruby-keyword">module</span> <span class="ruby-constant">M</span>
  <span class="ruby-identifier">refine</span> <span class="ruby-constant">C</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">foo</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;C#foo in M&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>m_user.rb:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;m&quot;</span>

<span class="ruby-identifier">using</span> <span class="ruby-constant">M</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">MUser</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">call_foo</span>(<span class="ruby-identifier">x</span>)
    <span class="ruby-identifier">x</span>.<span class="ruby-identifier">foo</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>main.rb:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;m_user&quot;</span>

<span class="ruby-identifier">x</span> = <span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">m_user</span> = <span class="ruby-constant">MUser</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">m_user</span>.<span class="ruby-identifier">call_foo</span>(<span class="ruby-identifier">x</span>) <span class="ruby-comment"># prints &quot;C#foo in M&quot;</span>
<span class="ruby-identifier">x</span>.<span class="ruby-identifier">foo</span>              <span class="ruby-comment">#=&gt; raises NoMethodError</span>
</pre>

<p>Since the refinement <code>M</code> is active in <code>m_user.rb</code>
where <code>MUser#call_foo</code> is defined it is also active when
<code>main.rb</code> calls <code>call_foo</code>.</p>

<p>Since using is a method, refinements are only active when it is called. 
Here are examples of where a refinement <code>M</code> is and is not
active.</p>

<p>In a file:</p>

<pre class="ruby"><span class="ruby-comment"># not activated here</span>
<span class="ruby-identifier">using</span> <span class="ruby-constant">M</span>
<span class="ruby-comment"># activated here</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Foo</span>
  <span class="ruby-comment"># activated here</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">foo</span>
    <span class="ruby-comment"># activated here</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># activated here</span>
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># activated here</span>
</pre>

<p>In a class:</p>

<pre class="ruby"><span class="ruby-comment"># not activated here</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Foo</span>
  <span class="ruby-comment"># not activated here</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">foo</span>
    <span class="ruby-comment"># not activated here</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">using</span> <span class="ruby-constant">M</span>
  <span class="ruby-comment"># activated here</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">bar</span>
    <span class="ruby-comment"># activated here</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># activated here</span>
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># not activated here</span>
</pre>

<p>Note that the refinements in M are not activated automatically if the class
Foo is reopened later.</p>

<p>In eval:</p>

<pre class="ruby"><span class="ruby-comment"># not activated here</span>
<span class="ruby-identifier">eval</span> <span class="ruby-value">&lt;&lt;EOF
  # not activated here
  using M
  # activated here
EOF</span>
<span class="ruby-comment"># not activated here</span>
</pre>

<p>When not evaluated:</p>

<pre class="ruby"><span class="ruby-comment"># not activated here</span>
<span class="ruby-keyword">if</span> <span class="ruby-keyword">false</span>
  <span class="ruby-identifier">using</span> <span class="ruby-constant">M</span>
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># not activated here</span>
</pre>

<p>When defining multiple refinements in the same module, inside a refine
block all refinements from the same module are active when a refined method
is called:</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">ToJSON</span>
  <span class="ruby-identifier">refine</span> <span class="ruby-constant">Integer</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">to_json</span>
      <span class="ruby-identifier">to_s</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">refine</span> <span class="ruby-constant">Array</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">to_json</span>
      <span class="ruby-string">&quot;[&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">to_json</span> }.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;,&quot;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;]&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">refine</span> <span class="ruby-constant">Hash</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">to_json</span>
      <span class="ruby-string">&quot;{&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">dump</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;:&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">to_json</span> }.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;,&quot;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">using</span> <span class="ruby-constant">ToJSON</span>

<span class="ruby-identifier">p</span> [{<span class="ruby-value">1</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}, {<span class="ruby-value">3</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">4</span>}].<span class="ruby-identifier">to_json</span> <span class="ruby-comment"># prints &quot;[{\&quot;1\&quot;:2},{\&quot;3\&quot;:4}]&quot;</span>
</pre>

<h2 id="label-Method+Lookup"><a href="../Method.html">Method</a> Lookup<span><a href="#label-Method+Lookup">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When looking up a method for an instance of class <code>C</code> Ruby
checks:</p>
<ul><li>
<p>If refinements are active for <code>C</code>, in the reverse order they
were activated:</p>
<ul><li>
<p>The prepended modules from the refinement for <code>C</code></p>
</li><li>
<p>The refinement for <code>C</code></p>
</li><li>
<p>The included modules from the refinement for <code>C</code></p>
</li></ul>
</li><li>
<p>The prepended modules of <code>C</code></p>
</li><li>
<p><code>C</code></p>
</li><li>
<p>The included modules of <code>C</code></p>
</li></ul>

<p>If no method was found at any point this repeats with the superclass of
<code>C</code>.</p>

<p>Note that methods in a subclass have priority over refinements in a
superclass.  For example, if the method <code>/</code> is defined in a
refinement for <a href="../Integer.html">Integer</a> <code>1 / 2</code>
invokes the original Fixnum#/ because Fixnum is a subclass of <a
href="../Integer.html">Integer</a> and is searched before the refinements
for the superclass <a href="../Integer.html">Integer</a>.</p>

<p>If a method <code>foo</code> is defined on <a
href="../Integer.html">Integer</a> in a refinement, <code>1.foo</code>
invokes that method since <code>foo</code> does not exist on Fixnum.</p>

<h2 id="label-super"><code>super</code><span><a href="#label-super">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When <code>super</code> is invoked method lookup checks:</p>
<ul><li>
<p>The included modules of the current class.  Note that the current class may
be a refinement.</p>
</li><li>
<p>If the current class is a refinement, the method lookup proceeds as in the
<a href="../Method.html">Method</a> Lookup section above.</p>
</li><li>
<p>If the current class has a direct superclass, the method proceeds as in the
<a href="../Method.html">Method</a> Lookup section above using the
superclass.</p>
</li></ul>

<p>Note that <code>super</code> in a method of a refinement invokes the method
in the refined class even if there is another refinement which has been
activated in the same context.</p>

<h2 id="label-Indirect+Method+Calls">Indirect <a href="../Method.html">Method</a> Calls<span><a href="#label-Indirect+Method+Calls">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When using indirect method access such as Kernel#send, Kernel#method or
Kernel#respond_to? refinements are not honored for the caller context
during method lookup.</p>

<p>This behavior may be changed in the future.</p>

<h2 id="label-Further+Reading">Further Reading<span><a href="#label-Further+Reading">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>See <a
href="https://bugs.ruby-lang.org/projects/ruby-trunk/wiki/RefinementsSpec">bugs.ruby-lang.org/projects/ruby-trunk/wiki/RefinementsSpec</a>
for the current specification for implementing refinements.  The
specification also contains more details.</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

