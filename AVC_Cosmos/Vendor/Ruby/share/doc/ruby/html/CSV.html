<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class CSV - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#class-CSV-label-Reading">Reading</a>
    <li><a href="#class-CSV-label-From+a+File">From a File</a>
    <li><a href="#class-CSV-label-A+Line+at+a+Time">A Line at a Time</a>
    <li><a href="#class-CSV-label-All+at+Once">All at Once</a>
    <li><a href="#class-CSV-label-From+a+String">From a String</a>
    <li><a href="#class-CSV-label-A+Line+at+a+Time">A Line at a Time</a>
    <li><a href="#class-CSV-label-All+at+Once">All at Once</a>
    <li><a href="#class-CSV-label-Writing">Writing</a>
    <li><a href="#class-CSV-label-To+a+File">To a File</a>
    <li><a href="#class-CSV-label-To+a+String">To a String</a>
    <li><a href="#class-CSV-label-Convert+a+Single+Line">Convert a Single Line</a>
    <li><a href="#class-CSV-label-Shortcut+Interface">Shortcut Interface</a>
    <li><a href="#class-CSV-label-Advanced+Usage">Advanced Usage</a>
    <li><a href="#class-CSV-label-Wrap+an+IO+Object">Wrap an IO Object</a>
    <li><a href="#class-CSV-label-CSV+and+Character+Encodings+-28M17n+or+Multilingualization-29">CSV and Character Encodings (M17n or Multilingualization)</a>
  </ul>
</div>


  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="Object.html">Object</a>
  
</div>

    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><a class="include" href="Enumerable.html">Enumerable</a>
  
  
  </ul>
</div>

    <div id="extends-section" class="nav-section">
  <h3>Extended With Modules</h3>

  <ul class="link-list">
    
  
    <li><a class="extend" href="Forwardable.html">Forwardable</a>
  
  
  </ul>
</div>

    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-filter">::filter</a>
    
    <li ><a href="#method-c-foreach">::foreach</a>
    
    <li ><a href="#method-c-generate">::generate</a>
    
    <li ><a href="#method-c-generate_line">::generate_line</a>
    
    <li ><a href="#method-c-instance">::instance</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-open">::open</a>
    
    <li ><a href="#method-c-parse">::parse</a>
    
    <li ><a href="#method-c-parse_line">::parse_line</a>
    
    <li ><a href="#method-c-read">::read</a>
    
    <li ><a href="#method-c-readlines">::readlines</a>
    
    <li ><a href="#method-c-table">::table</a>
    
    <li ><a href="#method-i-3C-3C">#&lt;&lt;</a>
    
    <li ><a href="#method-i-add_converter">#add_converter</a>
    
    <li ><a href="#method-i-add_row">#add_row</a>
    
    <li ><a href="#method-i-add_unconverted_fields">#add_unconverted_fields</a>
    
    <li ><a href="#method-i-convert">#convert</a>
    
    <li ><a href="#method-i-convert_fields">#convert_fields</a>
    
    <li ><a href="#method-i-converters">#converters</a>
    
    <li ><a href="#method-i-each">#each</a>
    
    <li ><a href="#method-i-encode_re">#encode_re</a>
    
    <li ><a href="#method-i-encode_str">#encode_str</a>
    
    <li ><a href="#method-i-escape_re">#escape_re</a>
    
    <li ><a href="#method-i-force_quotes-3F">#force_quotes?</a>
    
    <li ><a href="#method-i-gets">#gets</a>
    
    <li ><a href="#method-i-header_convert">#header_convert</a>
    
    <li ><a href="#method-i-header_converters">#header_converters</a>
    
    <li ><a href="#method-i-header_row-3F">#header_row?</a>
    
    <li ><a href="#method-i-headers">#headers</a>
    
    <li ><a href="#method-i-init_comments">#init_comments</a>
    
    <li ><a href="#method-i-init_converters">#init_converters</a>
    
    <li ><a href="#method-i-init_headers">#init_headers</a>
    
    <li ><a href="#method-i-init_parsers">#init_parsers</a>
    
    <li ><a href="#method-i-init_separators">#init_separators</a>
    
    <li ><a href="#method-i-inspect">#inspect</a>
    
    <li ><a href="#method-i-liberal_parsing-3F">#liberal_parsing?</a>
    
    <li ><a href="#method-i-parse_headers">#parse_headers</a>
    
    <li ><a href="#method-i-puts">#puts</a>
    
    <li ><a href="#method-i-raw_encoding">#raw_encoding</a>
    
    <li ><a href="#method-i-read">#read</a>
    
    <li ><a href="#method-i-readline">#readline</a>
    
    <li ><a href="#method-i-readlines">#readlines</a>
    
    <li ><a href="#method-i-return_headers-3F">#return_headers?</a>
    
    <li ><a href="#method-i-rewind">#rewind</a>
    
    <li ><a href="#method-i-shift">#shift</a>
    
    <li ><a href="#method-i-skip_blanks-3F">#skip_blanks?</a>
    
    <li ><a href="#method-i-unconverted_fields-3F">#unconverted_fields?</a>
    
    <li ><a href="#method-i-write_headers-3F">#write_headers?</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-CSV">
  <h1 id="class-CSV" class="class">
    class CSV
  </h1>

  <section class="description">
    
<p>This class provides a complete interface to <a href="CSV.html">CSV</a>
files and data.  It offers tools to enable you to read and write to and
from Strings or <a href="IO.html">IO</a> objects, as needed.</p>

<h2 id="class-CSV-label-Reading">Reading<span><a href="#class-CSV-label-Reading">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="class-CSV-label-From+a+File">From a <a href="File.html">File</a><span><a href="#class-CSV-label-From+a+File">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="class-CSV-label-A+Line+at+a+Time">A Line at a <a href="Time.html">Time</a><span><a href="#class-CSV-label-A+Line+at+a+Time">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">CSV</span>.<span class="ruby-identifier">foreach</span>(<span class="ruby-string">&quot;path/to/file.csv&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>
  <span class="ruby-comment"># use row here...</span>
<span class="ruby-keyword">end</span>
</pre>

<h4 id="class-CSV-label-All+at+Once">All at Once<span><a href="#class-CSV-label-All+at+Once">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-identifier">arr_of_arrs</span> = <span class="ruby-constant">CSV</span>.<span class="ruby-identifier">read</span>(<span class="ruby-string">&quot;path/to/file.csv&quot;</span>)
</pre>

<h3 id="class-CSV-label-From+a+String">From a String<span><a href="#class-CSV-label-From+a+String">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="class-CSV-label-A+Line+at+a+Time">A Line at a <a href="Time.html">Time</a><span><a href="#class-CSV-label-A+Line+at+a+Time">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">CSV</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;CSV,data,String&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>
  <span class="ruby-comment"># use row here...</span>
<span class="ruby-keyword">end</span>
</pre>

<h4 id="class-CSV-label-All+at+Once">All at Once<span><a href="#class-CSV-label-All+at+Once">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-identifier">arr_of_arrs</span> = <span class="ruby-constant">CSV</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;CSV,data,String&quot;</span>)
</pre>

<h2 id="class-CSV-label-Writing">Writing<span><a href="#class-CSV-label-Writing">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="class-CSV-label-To+a+File">To a <a href="File.html">File</a><span><a href="#class-CSV-label-To+a+File">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-constant">CSV</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;path/to/file.csv&quot;</span>, <span class="ruby-string">&quot;wb&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">csv</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-string">&quot;row&quot;</span>, <span class="ruby-string">&quot;of&quot;</span>, <span class="ruby-string">&quot;CSV&quot;</span>, <span class="ruby-string">&quot;data&quot;</span>]
  <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-string">&quot;another&quot;</span>, <span class="ruby-string">&quot;row&quot;</span>]
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="class-CSV-label-To+a+String">To a String<span><a href="#class-CSV-label-To+a+String">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">csv_string</span> = <span class="ruby-constant">CSV</span>.<span class="ruby-identifier">generate</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">csv</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-string">&quot;row&quot;</span>, <span class="ruby-string">&quot;of&quot;</span>, <span class="ruby-string">&quot;CSV&quot;</span>, <span class="ruby-string">&quot;data&quot;</span>]
  <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-string">&quot;another&quot;</span>, <span class="ruby-string">&quot;row&quot;</span>]
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="class-CSV-label-Convert+a+Single+Line">Convert a Single Line<span><a href="#class-CSV-label-Convert+a+Single+Line">&para;</a> <a href="#top">&uarr;</a></span></h2>

<pre class="ruby"><span class="ruby-identifier">csv_string</span> = [<span class="ruby-string">&quot;CSV&quot;</span>, <span class="ruby-string">&quot;data&quot;</span>].<span class="ruby-identifier">to_csv</span>   <span class="ruby-comment"># to CSV</span>
<span class="ruby-identifier">csv_array</span>  = <span class="ruby-string">&quot;CSV,String&quot;</span>.<span class="ruby-identifier">parse_csv</span>   <span class="ruby-comment"># from CSV</span>
</pre>

<h2 id="class-CSV-label-Shortcut+Interface">Shortcut Interface<span><a href="#class-CSV-label-Shortcut+Interface">&para;</a> <a href="#top">&uarr;</a></span></h2>

<pre class="ruby"><span class="ruby-constant">CSV</span>             { <span class="ruby-operator">|</span><span class="ruby-identifier">csv_out</span><span class="ruby-operator">|</span> <span class="ruby-identifier">csv_out</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">%w{my data here}</span> }  <span class="ruby-comment"># to $stdout</span>
<span class="ruby-constant">CSV</span>(<span class="ruby-identifier">csv</span> = <span class="ruby-string">&quot;&quot;</span>)   { <span class="ruby-operator">|</span><span class="ruby-identifier">csv_str</span><span class="ruby-operator">|</span> <span class="ruby-identifier">csv_str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">%w{my data here}</span> }  <span class="ruby-comment"># to a String</span>
<span class="ruby-constant">CSV</span>(<span class="ruby-identifier">$stderr</span>)    { <span class="ruby-operator">|</span><span class="ruby-identifier">csv_err</span><span class="ruby-operator">|</span> <span class="ruby-identifier">csv_err</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">%w{my data here}</span> }  <span class="ruby-comment"># to $stderr</span>
<span class="ruby-constant">CSV</span>(<span class="ruby-identifier">$stdin</span>)     { <span class="ruby-operator">|</span><span class="ruby-identifier">csv_in</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">csv_in</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">row</span> } }  <span class="ruby-comment"># from $stdin</span>
</pre>

<h2 id="class-CSV-label-Advanced+Usage">Advanced Usage<span><a href="#class-CSV-label-Advanced+Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="class-CSV-label-Wrap+an+IO+Object">Wrap an <a href="IO.html">IO</a> <a href="Object.html">Object</a><span><a href="#class-CSV-label-Wrap+an+IO+Object">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">csv</span> = <span class="ruby-constant">CSV</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">options</span>)
<span class="ruby-comment"># ... read (with gets() or each()) from and write (with &lt;&lt;) to csv here ...</span>
</pre>

<h2 id="class-CSV-label-CSV+and+Character+Encodings+-28M17n+or+Multilingualization-29"><a href="CSV.html">CSV</a> and Character Encodings (M17n or Multilingualization)<span><a href="#class-CSV-label-CSV+and+Character+Encodings+-28M17n+or+Multilingualization-29">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This new <a href="CSV.html">CSV</a> parser is m17n savvy.  The parser works
in the <a href="Encoding.html">Encoding</a> of the <a href="IO.html">IO</a>
or String object being read from or written to.  Your data is never
transcoded (unless you ask Ruby to transcode it for you) and will literally
be parsed in the <a href="Encoding.html">Encoding</a> it is in.  Thus <a
href="CSV.html">CSV</a> will return Arrays or Rows of Strings in the <a
href="Encoding.html">Encoding</a> of your data.  This is accomplished by
transcoding the parser itself into your <a
href="Encoding.html">Encoding</a>.</p>

<p>Some transcoding must take place, of course, to accomplish this
multiencoding support.  For example, <code>:col_sep</code>,
<code>:row_sep</code>, and <code>:quote_char</code> must be transcoded to
match your data.  Hopefully this makes the entire process feel transparent,
since CSV&#39;s defaults should just magically work for your data. 
However, you can set these values manually in the target <a
href="Encoding.html">Encoding</a> to avoid the translation.</p>

<p>It&#39;s also important to note that while all of CSV&#39;s core parser is
now <a href="Encoding.html">Encoding</a> agnostic, some features are not. 
For example, the built-in converters will try to transcode data to UTF-8
before making conversions. Again, you can provide custom converters that
are aware of your Encodings to avoid this translation.  It&#39;s just too
hard for me to support native conversions in all of Ruby&#39;s Encodings.</p>

<p>Anyway, the practical side of this is simple:  make sure <a
href="IO.html">IO</a> and String objects passed into <a
href="CSV.html">CSV</a> have the proper <a
href="Encoding.html">Encoding</a> set and everything should just work. <a
href="CSV.html">CSV</a> methods that allow you to open <a
href="IO.html">IO</a> objects (CSV::foreach(), <a
href="CSV.html#method-c-open">::open</a>, <a
href="CSV.html#method-c-read">::read</a>, and <a
href="CSV.html#method-c-readlines">::readlines</a>) do allow you to specify
the <a href="Encoding.html">Encoding</a>.</p>

<p>One minor exception comes when generating <a href="CSV.html">CSV</a> into a
String with an <a href="Encoding.html">Encoding</a> that is not ASCII
compatible.  There&#39;s no existing data for <a href="CSV.html">CSV</a> to
use to prepare itself and thus you will probably need to manually specify
the desired <a href="Encoding.html">Encoding</a> for most of those cases. 
It will try to guess using the fields in a row of output though, when using
<a href="CSV.html#method-c-generate_line">::generate_line</a> or
Array#to_csv().</p>

<p>I try to point out any other <a href="Encoding.html">Encoding</a> issues in
the documentation of methods as they come up.</p>

<p>This has been tested to the best of my ability with all non-“dummy”
Encodings Ruby ships with.  However, it is brave new code and may have some
bugs. Please feel free to <a
href="mailto:james@grayproductions.net">report</a> any issues you find with
it.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="ConverterEncoding">ConverterEncoding
        
        <dd><p>The encoding used by all converters.</p>
        
      
        <dt id="Converters">Converters
        
        <dd><p>This <a href="Hash.html">Hash</a> holds the built-in converters of <a
href="CSV.html">CSV</a> that can be accessed by name. You can select <a
href="CSV.html#Converters">Converters</a> with <a
href="CSV.html#method-i-convert">#convert</a> or through the
<code>options</code> <a href="Hash.html">Hash</a> passed to <a
href="CSV.html#method-c-new">::new</a>.</p>
<dl class="rdoc-list note-list"><dt><strong><code>:integer</code></strong>
<dd>
<p>Converts any field Integer() accepts.</p>
</dd><dt><strong><code>:float</code></strong>
<dd>
<p>Converts any field Float() accepts.</p>
</dd><dt><strong><code>:numeric</code></strong>
<dd>
<p>A combination of <code>:integer</code> and <code>:float</code>.</p>
</dd><dt><strong><code>:date</code></strong>
<dd>
<p>Converts any field <a href="Date.html#method-c-parse">Date.parse</a>
accepts.</p>
</dd><dt><strong><code>:date_time</code></strong>
<dd>
<p>Converts any field <a
href="DateTime.html#method-c-parse">DateTime.parse</a> accepts.</p>
</dd><dt><strong><code>:all</code></strong>
<dd>
<p>All built-in converters.  A combination of <code>:date_time</code> and
<code>:numeric</code>.</p>
</dd></dl>

<p>All built-in converters transcode field data to UTF-8 before attempting a
conversion.  If your data cannot be transcoded to UTF-8 the conversion will
fail and the field will remain unchanged.</p>

<p>This <a href="Hash.html">Hash</a> is intentionally left unfrozen and users
should feel free to add values to it that can be accessed by all <a
href="CSV.html">CSV</a> objects.</p>

<p>To add a combo field, the value should be an Array of names.  Combo fields
can be nested with other combo fields.</p>
        
      
        <dt id="DEFAULT_OPTIONS">DEFAULT_OPTIONS
        
        <dd><p>The options used when no overrides are given by calling code.  They are:</p>
<dl class="rdoc-list note-list"><dt><strong><code>:col_sep</code></strong>
<dd>
<p><code>&quot;,&quot;</code></p>
</dd><dt><strong><code>:row_sep</code></strong>
<dd>
<p><code>:auto</code></p>
</dd><dt><strong><code>:quote_char</code></strong>
<dd>
<p><code>&#39;&quot;&#39;</code></p>
</dd><dt><strong><code>:field_size_limit</code></strong>
<dd>
<p><code>nil</code></p>
</dd><dt><strong><code>:converters</code></strong>
<dd>
<p><code>nil</code></p>
</dd><dt><strong><code>:unconverted_fields</code></strong>
<dd>
<p><code>nil</code></p>
</dd><dt><strong><code>:headers</code></strong>
<dd>
<p><code>false</code></p>
</dd><dt><strong><code>:return_headers</code></strong>
<dd>
<p><code>false</code></p>
</dd><dt><strong><code>:header_converters</code></strong>
<dd>
<p><code>nil</code></p>
</dd><dt><strong><code>:skip_blanks</code></strong>
<dd>
<p><code>false</code></p>
</dd><dt><strong><code>:force_quotes</code></strong>
<dd>
<p><code>false</code></p>
</dd><dt><strong><code>:skip_lines</code></strong>
<dd>
<p><code>nil</code></p>
</dd><dt><strong><code>:liberal_parsing</code></strong>
<dd>
<p><code>false</code></p>
</dd></dl>
        
      
        <dt id="DateMatcher">DateMatcher
        
        <dd><p>A <a href="Regexp.html">Regexp</a> used to find and convert some common <a
href="Date.html">Date</a> formats.</p>
        
      
        <dt id="DateTimeMatcher">DateTimeMatcher
        
        <dd><p>A <a href="Regexp.html">Regexp</a> used to find and convert some common <a
href="DateTime.html">DateTime</a> formats.</p>
        
      
        <dt id="FieldInfo">FieldInfo
        
        <dd><p>A <a href="CSV.html#FieldInfo">FieldInfo</a> <a
href="Struct.html">Struct</a> contains details about a field&#39;s position
in the data source it was read from.  <a href="CSV.html">CSV</a> will pass
this <a href="Struct.html">Struct</a> to some blocks that make decisions
based on field structure.  See <a
href="CSV.html#method-i-convert_fields">#convert_fields</a> for an example.</p>
<dl class="rdoc-list note-list"><dt><strong><code>index</code></strong>
<dd>
<p>The zero-based index of the field in its row.</p>
</dd><dt><strong><code>line</code></strong>
<dd>
<p>The line of the data source this row is from.</p>
</dd><dt><strong><code>header</code></strong>
<dd>
<p>The header for the column, when available.</p>
</dd></dl>
        
      
        <dt id="HeaderConverters">HeaderConverters
        
        <dd><p>This <a href="Hash.html">Hash</a> holds the built-in header converters of
<a href="CSV.html">CSV</a> that can be accessed by name.  You can select <a
href="CSV.html#HeaderConverters">HeaderConverters</a> with <a
href="CSV.html#method-i-header_convert">#header_convert</a> or through the
<code>options</code> <a href="Hash.html">Hash</a> passed to <a
href="CSV.html#method-c-new">::new</a>.</p>
<dl class="rdoc-list note-list"><dt><strong><code>:downcase</code></strong>
<dd>
<p>Calls downcase() on the header String.</p>
</dd><dt><strong><code>:symbol</code></strong>
<dd>
<p>Leading/trailing spaces are dropped, string is downcased, remaining spaces
are replaced with underscores, non-word characters are dropped, and finally
to_sym() is called.</p>
</dd></dl>

<p>All built-in header converters transcode header data to UTF-8 before
attempting a conversion.  If your data cannot be transcoded to UTF-8 the
conversion will fail and the header will remain unchanged.</p>

<p>This <a href="Hash.html">Hash</a> is intentionally left unfrozen and users
should feel free to add values to it that can be accessed by all <a
href="CSV.html">CSV</a> objects.</p>

<p>To add a combo field, the value should be an Array of names.  Combo fields
can be nested with other combo fields.</p>
        
      
        <dt id="VERSION">VERSION
        
        <dd><p>The version of the installed library.</p>
        
      
      </dl>
    </section>
    

    
    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      
      <div id="attribute-i-col_sep" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">col_sep</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The encoded <code>:col_sep</code> used in parsing and writing.  See <a
href="CSV.html#method-c-new">::new</a> for details.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-encoding" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">encoding</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The <a href="Encoding.html">Encoding</a> <a href="CSV.html">CSV</a> is
parsing or writing in.  This will be the <a
href="Encoding.html">Encoding</a> you receive parsed data in and/or the <a
href="Encoding.html">Encoding</a> data will be written in.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-field_size_limit" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">field_size_limit</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The limit for field size, if any.  See <a
href="CSV.html#method-c-new">::new</a> for details.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-lineno" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">lineno</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The line number of the last row read from this file.  Fields with nested
line-end characters will not affect this count.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-quote_char" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">quote_char</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The encoded <code>:quote_char</code> used in parsing and writing.  See <a
href="CSV.html#method-c-new">::new</a> for details.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-row_sep" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">row_sep</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The encoded <code>:row_sep</code> used in parsing and writing.  See <a
href="CSV.html#method-c-new">::new</a> for details.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-skip_lines" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">skip_lines</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The regex marking a line as a comment. See <a
href="CSV.html#method-c-new">::new</a> for details</p>
        
        </div>
      </div>
      
    </section>
    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-filter" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            filter( options = Hash.new ) { |row| ... }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            filter( input, options = Hash.new ) { |row| ... }
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            filter( input, output, options = Hash.new ) { |row| ... }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This method is a convenience for building Unix-like filters for <a
href="CSV.html">CSV</a> data. Each row is yielded to the provided block
which can alter it as needed. After the block returns, the row is appended
to <code>output</code> altered or not.</p>

<p>The <code>input</code> and <code>output</code> arguments can be anything <a
href="CSV.html#method-c-new">::new</a> accepts (generally String or <a
href="IO.html">IO</a> objects).  If not given, they default to
<code>ARGF</code> and <code>$stdout</code>.</p>

<p>The <code>options</code> parameter is also filtered down to <a
href="CSV.html#method-c-new">::new</a> after some clever key parsing.  Any
key beginning with <code>:in_</code> or <code>:input_</code> will have that
leading identifier stripped and will only be used in the
<code>options</code> <a href="Hash.html">Hash</a> for the
<code>input</code> object.  Keys starting with <code>:out_</code> or
<code>:output_</code> affect only <code>output</code>.  All other keys are
assigned to both objects.</p>

<p>The <code>:output_row_sep</code> <code>option</code> defaults to
<code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>).</p>
          
          

          
          <div class="method-source-code" id="filter-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1102</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-comment"># parse options for input, output, or both</span>
  <span class="ruby-identifier">in_options</span>, <span class="ruby-identifier">out_options</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>, {<span class="ruby-identifier">row_sep</span><span class="ruby-operator">:</span> <span class="ruby-identifier">$INPUT_RECORD_SEPARATOR</span>}
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-identifier">args</span>.<span class="ruby-identifier">pop</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_s</span>
      <span class="ruby-keyword">when</span> <span class="ruby-regexp">/\Ain(?:put)?_(.+)\Z/</span>
        <span class="ruby-identifier">in_options</span>[<span class="ruby-node">$1</span>.<span class="ruby-identifier">to_sym</span>] = <span class="ruby-identifier">value</span>
      <span class="ruby-keyword">when</span> <span class="ruby-regexp">/\Aout(?:put)?_(.+)\Z/</span>
        <span class="ruby-identifier">out_options</span>[<span class="ruby-node">$1</span>.<span class="ruby-identifier">to_sym</span>] = <span class="ruby-identifier">value</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">in_options</span>[<span class="ruby-identifier">key</span>]  = <span class="ruby-identifier">value</span>
        <span class="ruby-identifier">out_options</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">value</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># build input and output wrappers</span>
  <span class="ruby-identifier">input</span>  = <span class="ruby-identifier">new</span>(<span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">||</span> <span class="ruby-constant">ARGF</span>,    <span class="ruby-identifier">in_options</span>)
  <span class="ruby-identifier">output</span> = <span class="ruby-identifier">new</span>(<span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">$stdout</span>, <span class="ruby-identifier">out_options</span>)

  <span class="ruby-comment"># read, yield, write</span>
  <span class="ruby-identifier">input</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-identifier">row</span>
    <span class="ruby-identifier">output</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">row</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-foreach" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">foreach</span><span
            class="method-args">(path, options = Hash.new, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This method is intended as the primary interface for reading <a
href="CSV.html">CSV</a> files.  You pass a <code>path</code> and any
<code>options</code> you wish to set for the read.  Each row of file will
be passed to the provided <code>block</code> in turn.</p>

<p>The <code>options</code> parameter can be anything <a
href="CSV.html#method-c-new">::new</a> understands.  This method also
understands an additional <code>:encoding</code> parameter that you can use
to specify the <a href="Encoding.html">Encoding</a> of the data in the file
to be read. You must provide this unless your data is in <a
href="Encoding.html#method-c-default_external">Encoding.default_external</a>.
<a href="CSV.html">CSV</a> will use this to determine how to parse the
data.  You may provide a second <a href="Encoding.html">Encoding</a> to
have the data transcoded as it is read.  For example, <code>encoding:
&quot;UTF-32BE:UTF-8&quot;</code> would read UTF-32BE data from the file
but transcode it to UTF-8 before <a href="CSV.html">CSV</a> parses it.</p>
          
          

          
          <div class="method-source-code" id="foreach-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1143</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">foreach</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">to_enum</span>(<span class="ruby-identifier">__method__</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">options</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">open</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">options</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">csv</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-generate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            generate( str, options = Hash.new ) { |csv| ... }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            generate( options = Hash.new ) { |csv| ... }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This method wraps a String you provide, or an empty default String, in a <a
href="CSV.html">CSV</a> object which is passed to the provided block.  You
can use the block to append <a href="CSV.html">CSV</a> rows to the String
and when the block exits, the final String will be returned.</p>

<p>Note that a passed String <strong>is</strong> modified by this method. 
Call dup() before passing if you need a new String.</p>

<p>The <code>options</code> parameter can be anything <a
href="CSV.html#method-c-new">::new</a> understands.  This method
understands an additional <code>:encoding</code> parameter when not passed
a String to set the base <a href="Encoding.html">Encoding</a> for the
output.  <a href="CSV.html">CSV</a> needs this hint if you plan to output
non-ASCII compatible data.</p>
          
          

          
          <div class="method-source-code" id="generate-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1168</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">generate</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-comment"># add a default empty String, if none was given</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">String</span>
    <span class="ruby-identifier">io</span> = <span class="ruby-constant">StringIO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span>)
    <span class="ruby-identifier">io</span>.<span class="ruby-identifier">seek</span>(<span class="ruby-value">0</span>, <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">SEEK_END</span>)
    <span class="ruby-identifier">args</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">io</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">-1</span>][<span class="ruby-value">:encoding</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>)
    <span class="ruby-identifier">str</span>      = <span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>
    <span class="ruby-identifier">str</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-identifier">encoding</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">encoding</span>
    <span class="ruby-identifier">args</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">str</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">csv</span> = <span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)  <span class="ruby-comment"># wrap</span>
  <span class="ruby-keyword">yield</span> <span class="ruby-identifier">csv</span>         <span class="ruby-comment"># yield for appending</span>
  <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">string</span>        <span class="ruby-comment"># return final String</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-generate_line" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">generate_line</span><span
            class="method-args">(row, options = Hash.new)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This method is a shortcut for converting a single row (Array) into a <a
href="CSV.html">CSV</a> String.</p>

<p>The <code>options</code> parameter can be anything <a
href="CSV.html#method-c-new">::new</a> understands.  This method
understands an additional <code>:encoding</code> parameter to set the base
<a href="Encoding.html">Encoding</a> for the output.  This method will try
to guess your <a href="Encoding.html">Encoding</a> from the first
non-<code>nil</code> field in <code>row</code>, if possible, but you may
need to use this parameter as a backup plan.</p>

<p>The <code>:row_sep</code> <code>option</code> defaults to
<code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>) when calling this
method.</p>
          
          

          
          <div class="method-source-code" id="generate_line-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1198</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">generate_line</span>(<span class="ruby-identifier">row</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>)
  <span class="ruby-identifier">options</span>  = {<span class="ruby-identifier">row_sep</span><span class="ruby-operator">:</span> <span class="ruby-identifier">$INPUT_RECORD_SEPARATOR</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:encoding</span>)
  <span class="ruby-identifier">str</span>      = <span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">encoding</span>
    <span class="ruby-identifier">str</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-identifier">encoding</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">field</span> = <span class="ruby-identifier">row</span>.<span class="ruby-identifier">find</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">nil?</span> }
    <span class="ruby-identifier">str</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-constant">String</span>(<span class="ruby-identifier">field</span>).<span class="ruby-identifier">encoding</span>)
  <span class="ruby-keyword">end</span>
  (<span class="ruby-identifier">new</span>(<span class="ruby-identifier">str</span>, <span class="ruby-identifier">options</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">row</span>).<span class="ruby-identifier">string</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-instance" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">instance</span><span
            class="method-args">(data = $stdout, options = Hash.new) { |instance| ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This method will return a <a href="CSV.html">CSV</a> instance, just like <a
href="CSV.html#method-c-new">::new</a>, but the instance will be cached and
returned for all future calls to this method for the same <code>data</code>
object (tested by <a
href="Object.html#method-i-object_id">Object#object_id</a>) with the same
<code>options</code>.</p>

<p>If a block is given, the instance is passed to the block and the return
value becomes the return value of the block.</p>
          
          

          
          <div class="method-source-code" id="instance-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1062</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">instance</span>(<span class="ruby-identifier">data</span> = <span class="ruby-identifier">$stdout</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>)
  <span class="ruby-comment"># create a _signature_ for this method call, data object and options</span>
  <span class="ruby-identifier">sig</span> = [<span class="ruby-identifier">data</span>.<span class="ruby-identifier">object_id</span>] <span class="ruby-operator">+</span>
        <span class="ruby-identifier">options</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-operator">*</span><span class="ruby-constant">DEFAULT_OPTIONS</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">sym</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sym</span>.<span class="ruby-identifier">to_s</span> })

  <span class="ruby-comment"># fetch or create the instance for this signature</span>
  <span class="ruby-identifier">@@instances</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">instance</span>    =   (<span class="ruby-identifier">@@instances</span>[<span class="ruby-identifier">sig</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">new</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">options</span>))

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-identifier">instance</span>  <span class="ruby-comment"># run block, if given, returning result</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">instance</span>        <span class="ruby-comment"># or return the instance</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(data, options = Hash.new)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This constructor will wrap either a String or <a href="IO.html">IO</a>
object passed in <code>data</code> for reading and/or writing.  In addition
to the <a href="CSV.html">CSV</a> instance methods, several <a
href="IO.html">IO</a> methods are delegated.  (See <a
href="CSV.html#method-c-open">::open</a> for a complete list.)  If you pass
a String for <code>data</code>, you can later retrieve it (after writing to
it, for example) with CSV.string().</p>

<p>Note that a wrapped String will be positioned at the beginning (for
reading).  If you want it at the end (for writing), use <a
href="CSV.html#method-c-generate">::generate</a>. If you want any other
positioning, pass a preset <a href="StringIO.html">StringIO</a> object
instead.</p>

<p>You may set any reading and/or writing preferences in the
<code>options</code> <a href="Hash.html">Hash</a>. Available options are:</p>
<dl class="rdoc-list note-list"><dt><strong><code>:col_sep</code></strong>
<dd>
<p>The String placed between each field. This String will be transcoded into
the data&#39;s <a href="Encoding.html">Encoding</a> before parsing.</p>
</dd><dt><strong><code>:row_sep</code></strong>
<dd>
<p>The String appended to the end of each row.  This can be set to the special
<code>:auto</code> setting, which requests that <a href="CSV.html">CSV</a>
automatically discover this from the data.  Auto-discovery reads ahead in
the data looking for the next <code>&quot;\r\n&quot;</code>,
<code>&quot;\n&quot;</code>, or <code>&quot;\r&quot;</code> sequence.  A
sequence will be selected even if it occurs in a quoted field, assuming
that you would have the same line endings there.  If none of those
sequences is found, <code>data</code> is <code>ARGF</code>,
<code>STDIN</code>, <code>STDOUT</code>, or <code>STDERR</code>, or the
stream is only available for output, the default
<code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>) is used.  Obviously,
discovery takes a little time.  <a href="Set.html">Set</a> manually if
speed is important.  Also note that <a href="IO.html">IO</a> objects should
be opened in binary mode on Windows if this feature will be used as the
line-ending translation can cause problems with resetting the document
position to where it was before the read ahead. This String will be
transcoded into the data&#39;s <a href="Encoding.html">Encoding</a> before
parsing.</p>
</dd><dt><strong><code>:quote_char</code></strong>
<dd>
<p>The character used to quote fields. This has to be a single character
String.  This is useful for application that incorrectly use
<code>&#39;</code> as the quote character instead of the correct
<code>&quot;</code>. <a href="CSV.html">CSV</a> will always consider a
double sequence of this character to be an escaped quote. This String will
be transcoded into the data&#39;s <a href="Encoding.html">Encoding</a>
before parsing.</p>
</dd><dt><strong><code>:field_size_limit</code></strong>
<dd>
<p>This is a maximum size <a href="CSV.html">CSV</a> will read ahead looking
for the closing quote for a field.  (In truth, it reads to the first line
ending beyond this size.)  If a quote cannot be found within the limit <a
href="CSV.html">CSV</a> will raise a <a
href="CSV/MalformedCSVError.html">MalformedCSVError</a>, assuming the data
is faulty.  You can use this limit to prevent what are effectively DoS
attacks on the parser.  However, this limit can cause a legitimate parse to
fail and thus is set to <code>nil</code>, or off, by default.</p>
</dd><dt><strong><code>:converters</code></strong>
<dd>
<p>An Array of names from the <a href="CSV.html#Converters">Converters</a> <a
href="Hash.html">Hash</a> and/or lambdas that handle custom conversion.  A
single converter doesn&#39;t have to be in an Array.  All built-in
converters try to transcode fields to UTF-8 before converting. The
conversion will fail if the data cannot be transcoded, leaving the field
unchanged.</p>
</dd><dt><strong><code>:unconverted_fields</code></strong>
<dd>
<p>If set to <code>true</code>, an unconverted_fields() method will be added
to all returned rows (Array or <a href="CSV/Row.html">CSV::Row</a>) that
will return the fields as they were before conversion.  Note that
<code>:headers</code> supplied by Array or String were not fields of the
document and thus will have an empty Array attached.</p>
</dd><dt><strong><code>:headers</code></strong>
<dd>
<p>If set to <code>:first_row</code> or <code>true</code>, the initial row of
the <a href="CSV.html">CSV</a> file will be treated as a row of headers. 
If set to an Array, the contents will be used as the headers. If set to a
String, the String is run through a call of <a
href="CSV.html#method-c-parse_line">::parse_line</a> with the same
<code>:col_sep</code>, <code>:row_sep</code>, and <code>:quote_char</code>
as this instance to produce an Array of headers.  This setting causes <a
href="CSV.html#method-i-shift">#shift</a> to return rows as <a
href="CSV/Row.html">CSV::Row</a> objects instead of Arrays and <a
href="CSV.html#method-i-read">#read</a> to return <a
href="CSV/Table.html">CSV::Table</a> objects instead of an Array of Arrays.</p>
</dd><dt><strong><code>:return_headers</code></strong>
<dd>
<p>When <code>false</code>, header rows are silently swallowed.  If set to
<code>true</code>, header rows are returned in a <a
href="CSV/Row.html">CSV::Row</a> object with identical headers and fields
(save that the fields do not go through the converters).</p>
</dd><dt><strong><code>:write_headers</code></strong>
<dd>
<p>When <code>true</code> and <code>:headers</code> is set, a header row will
be added to the output.</p>
</dd><dt><strong><code>:header_converters</code></strong>
<dd>
<p>Identical in functionality to <code>:converters</code> save that the
conversions are only made to header rows.  All built-in converters try to
transcode headers to UTF-8 before converting.  The conversion will fail if
the data cannot be transcoded, leaving the header unchanged.</p>
</dd><dt><strong><code>:skip_blanks</code></strong>
<dd>
<p>When set to a <code>true</code> value, <a href="CSV.html">CSV</a> will skip
over any empty rows. Note that this setting will not skip rows that contain
column separators, even if the rows contain no actual data. If you want to
skip rows that contain separators but no content, consider using
<code>:skip_lines</code>, or inspecting fields.compact.empty? on each row.</p>
</dd><dt><strong><code>:force_quotes</code></strong>
<dd>
<p>When set to a <code>true</code> value, <a href="CSV.html">CSV</a> will
quote all <a href="CSV.html">CSV</a> fields it creates.</p>
</dd><dt><strong><code>:skip_lines</code></strong>
<dd>
<p>When set to an object responding to <code>match</code>, every line matching
it is considered a comment and ignored during parsing. When set to a
String, it is first converted to a <a href="Regexp.html">Regexp</a>. When
set to <code>nil</code> no line is considered a comment. If the passed
object does not respond to <code>match</code>, <code>ArgumentError</code>
is thrown.</p>
</dd><dt><strong><code>:liberal_parsing</code></strong>
<dd>
<p>When set to a <code>true</code> value, <a href="CSV.html">CSV</a> will
attempt to parse input not conformant with RFC 4180, such as double quotes
in unquoted fields.</p>
</dd></dl>

<p>See <a href="CSV.html#DEFAULT_OPTIONS">CSV::DEFAULT_OPTIONS</a> for the
default settings.</p>

<p>Options cannot be overridden in the instance methods for performance
reasons, so be sure to set what you want here.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1527</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;Cannot parse nil as CSV&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># build the options for this read/write</span>
  <span class="ruby-identifier">options</span> = <span class="ruby-constant">DEFAULT_OPTIONS</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">options</span>)

  <span class="ruby-comment"># create the IO object we will read from</span>
  <span class="ruby-ivar">@io</span>       = <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>) <span class="ruby-operator">?</span> <span class="ruby-constant">StringIO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">data</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">data</span>
  <span class="ruby-comment"># honor the IO encoding if we can, otherwise default to ASCII-8BIT</span>
  <span class="ruby-ivar">@encoding</span> = <span class="ruby-identifier">raw_encoding</span>(<span class="ruby-keyword">nil</span>) <span class="ruby-operator">||</span>
              ( <span class="ruby-keyword">if</span> <span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:internal_encoding</span>)
                  <span class="ruby-keyword">case</span> <span class="ruby-identifier">encoding</span>
                  <span class="ruby-keyword">when</span> <span class="ruby-constant">Encoding</span>; <span class="ruby-identifier">encoding</span>
                  <span class="ruby-keyword">else</span> <span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">find</span>(<span class="ruby-identifier">encoding</span>)
                  <span class="ruby-keyword">end</span>
                <span class="ruby-keyword">end</span> ) <span class="ruby-operator">||</span>
              ( <span class="ruby-keyword">case</span> <span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:encoding</span>)
                <span class="ruby-keyword">when</span> <span class="ruby-constant">Encoding</span>; <span class="ruby-identifier">encoding</span>
                <span class="ruby-keyword">when</span> <span class="ruby-regexp">/\A[^:]+/</span>; <span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">find</span>(<span class="ruby-node">$&amp;</span>)
                <span class="ruby-keyword">end</span> ) <span class="ruby-operator">||</span>
              <span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">default_internal</span> <span class="ruby-operator">||</span> <span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">default_external</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># prepare for building safe regular expressions in the target encoding,</span>
  <span class="ruby-comment"># if we can transcode the needed characters</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-ivar">@re_esc</span>   =   <span class="ruby-string">&quot;\\&quot;</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-ivar">@encoding</span>).<span class="ruby-identifier">freeze</span> <span class="ruby-keyword">rescue</span> <span class="ruby-string">&quot;&quot;</span>
  <span class="ruby-ivar">@re_chars</span> =   <span class="ruby-node">/#{%&quot;[-\\]\\[\\.^$?*+{}()|# \r\n\t\f\v]&quot;.encode(@encoding)}/</span>

  <span class="ruby-identifier">init_separators</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-identifier">init_parsers</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-identifier">init_converters</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-identifier">init_headers</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-identifier">init_comments</span>(<span class="ruby-identifier">options</span>)

  <span class="ruby-ivar">@force_encoding</span> = <span class="ruby-operator">!</span><span class="ruby-operator">!</span>(<span class="ruby-identifier">encoding</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:encoding</span>))
  <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:internal_encoding</span>)
  <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:external_encoding</span>)
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;Unknown options:  #{options.keys.join(&#39;, &#39;)}.&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># track our own lineno since IO gets confused about line-ends is CSV fields</span>
  <span class="ruby-ivar">@lineno</span> = <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-open" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            open( filename, mode = &quot;rb&quot;, options = Hash.new ) { |faster_csv| ... }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            open( filename, options = Hash.new ) { |faster_csv| ... }
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            open( filename, mode = &quot;rb&quot;, options = Hash.new )
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            open( filename, options = Hash.new )
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This method opens an <a href="IO.html">IO</a> object, and wraps that with
<a href="CSV.html">CSV</a>.  This is intended as the primary interface for
writing a <a href="CSV.html">CSV</a> file.</p>

<p>You must pass a <code>filename</code> and may optionally add a
<code>mode</code> for Ruby&#39;s open().  You may also pass an optional <a
href="Hash.html">Hash</a> containing any <code>options</code> <a
href="CSV.html#method-c-new">::new</a> understands as the final argument.</p>

<p>This method works like Ruby&#39;s open() call, in that it will pass a <a
href="CSV.html">CSV</a> object to a provided block and close it when the
block terminates, or it will return the <a href="CSV.html">CSV</a> object
when no block is provided.  (<strong>Note</strong>: This is different from
the Ruby 1.8 <a href="CSV.html">CSV</a> library which passed rows to the
block.  Use <a href="CSV.html#method-c-foreach">::foreach</a> for that
behavior.)</p>

<p>You must provide a <code>mode</code> with an embedded <a
href="Encoding.html">Encoding</a> designator unless your data is in <a
href="Encoding.html#method-c-default_external">Encoding.default_external</a>.
<a href="CSV.html">CSV</a> will check the <a
href="Encoding.html">Encoding</a> of the underlying <a
href="IO.html">IO</a> object (set by the <code>mode</code> you pass) to
determine how to parse the data.   You may provide a second <a
href="Encoding.html">Encoding</a> to have the data transcoded as it is read
just as you can with a normal call to <a
href="IO.html#method-c-open">IO.open</a>.  For example,
<code>&quot;rb:UTF-32BE:UTF-8&quot;</code> would read UTF-32BE data from
the file but transcode it to UTF-8 before <a href="CSV.html">CSV</a> parses
it.</p>

<p>An opened <a href="CSV.html">CSV</a> object will delegate to many <a
href="IO.html">IO</a> methods for convenience.  You may call:</p>
<ul><li>
<p>binmode()</p>
</li><li>
<p>binmode?()</p>
</li><li>
<p>close()</p>
</li><li>
<p>close_read()</p>
</li><li>
<p>close_write()</p>
</li><li>
<p>closed?()</p>
</li><li>
<p>eof()</p>
</li><li>
<p>eof?()</p>
</li><li>
<p>external_encoding()</p>
</li><li>
<p>fcntl()</p>
</li><li>
<p>fileno()</p>
</li><li>
<p>flock()</p>
</li><li>
<p>flush()</p>
</li><li>
<p>fsync()</p>
</li><li>
<p>internal_encoding()</p>
</li><li>
<p>ioctl()</p>
</li><li>
<p>isatty()</p>
</li><li>
<p>path()</p>
</li><li>
<p>pid()</p>
</li><li>
<p>pos()</p>
</li><li>
<p>pos=()</p>
</li><li>
<p>reopen()</p>
</li><li>
<p>seek()</p>
</li><li>
<p>stat()</p>
</li><li>
<p>sync()</p>
</li><li>
<p>sync=()</p>
</li><li>
<p>tell()</p>
</li><li>
<p>to_i()</p>
</li><li>
<p>to_io()</p>
</li><li>
<p>truncate()</p>
</li><li>
<p>tty?()</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="open-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1273</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">open</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-comment"># find the +options+ Hash</span>
  <span class="ruby-identifier">options</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Hash</span> <span class="ruby-keyword">then</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">else</span> <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># wrap a File opened with the remaining +args+ with no newline</span>
  <span class="ruby-comment"># decorator</span>
  <span class="ruby-identifier">file_opts</span> = {<span class="ruby-identifier">universal_newline</span><span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-identifier">file_opts</span>)
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">ArgumentError</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-keyword">unless</span> <span class="ruby-regexp">/needs binmode/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">message</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">args</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;rb&quot;</span>
    <span class="ruby-identifier">file_opts</span> = {<span class="ruby-identifier">encoding</span><span class="ruby-operator">:</span> <span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">default_external</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">file_opts</span>)
    <span class="ruby-keyword">retry</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">csv</span> = <span class="ruby-identifier">new</span>(<span class="ruby-identifier">f</span>, <span class="ruby-identifier">options</span>)
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">close</span>
    <span class="ruby-identifier">raise</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># handle blocks like Ruby&#39;s open(), not like the CSV library</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">csv</span>
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">close</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">csv</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-parse" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            parse( str, options = Hash.new ) { |row| ... }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            parse( str, options = Hash.new )
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This method can be used to easily parse <a href="CSV.html">CSV</a> out of a
String.  You may either provide a <code>block</code> which will be called
with each row of the String in turn, or just use the returned Array of
Arrays (when no <code>block</code> is given).</p>

<p>You pass your <code>str</code> to read from, and an optional
<code>options</code> <a href="Hash.html">Hash</a> containing anything <a
href="CSV.html#method-c-new">::new</a> understands.</p>
          
          

          
          <div class="method-source-code" id="parse-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1318</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">csv</span> = <span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>  <span class="ruby-comment"># slurp contents, if no block is given</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">read</span>
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">close</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>           <span class="ruby-comment"># or pass each row to a provided block</span>
    <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-parse_line" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_line</span><span
            class="method-args">(line, options = Hash.new)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This method is a shortcut for converting a single line of a <a
href="CSV.html">CSV</a> String into an Array.  Note that if
<code>line</code> contains multiple rows, anything beyond the first row is
ignored.</p>

<p>The <code>options</code> parameter can be anything <a
href="CSV.html#method-c-new">::new</a> understands.</p>
          
          

          
          <div class="method-source-code" id="parse_line-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1338</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_line</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>)
  <span class="ruby-identifier">new</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">options</span>).<span class="ruby-identifier">shift</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-read" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">read</span><span
            class="method-args">(path, *options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Use to slurp a <a href="CSV.html">CSV</a> file into an Array of Arrays. 
Pass the <code>path</code> to the file and any <code>options</code> <a
href="CSV.html#method-c-new">::new</a> understands.  This method also
understands an additional <code>:encoding</code> parameter that you can use
to specify the <a href="Encoding.html">Encoding</a> of the data in the file
to be read. You must provide this unless your data is in <a
href="Encoding.html#method-c-default_external">Encoding.default_external</a>.
<a href="CSV.html">CSV</a> will use this to determine how to parse the
data.  You may provide a second <a href="Encoding.html">Encoding</a> to
have the data transcoded as it is read.  For example, <code>encoding:
&quot;UTF-32BE:UTF-8&quot;</code> would read UTF-32BE data from the file
but transcode it to UTF-8 before <a href="CSV.html">CSV</a> parses it.</p>
          
          

          
          <div class="method-source-code" id="read-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1353</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">read</span>(<span class="ruby-identifier">path</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">options</span>)
  <span class="ruby-identifier">open</span>(<span class="ruby-identifier">path</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">options</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">csv</span><span class="ruby-operator">|</span> <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">read</span> }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-readlines" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">readlines</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Alias for <a href="CSV.html#method-c-read">::read</a>.</p>
          
          

          
          <div class="method-source-code" id="readlines-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1358</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">readlines</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">read</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-table" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">table</span><span
            class="method-args">(path, options = Hash.new)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>A shortcut for:</p>

<pre class="ruby"><span class="ruby-constant">CSV</span>.<span class="ruby-identifier">read</span>( <span class="ruby-identifier">path</span>, { <span class="ruby-identifier">headers</span><span class="ruby-operator">:</span>           <span class="ruby-keyword">true</span>,
                  <span class="ruby-identifier">converters</span><span class="ruby-operator">:</span>        :<span class="ruby-identifier">numeric</span>,
                  <span class="ruby-identifier">header_converters</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">symbol</span> }.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">options</span>) )
</pre>
          
          

          
          <div class="method-source-code" id="table-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1369</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">table</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>)
  <span class="ruby-identifier">read</span>( <span class="ruby-identifier">path</span>, { <span class="ruby-identifier">headers</span><span class="ruby-operator">:</span>           <span class="ruby-keyword">true</span>,
                <span class="ruby-identifier">converters</span><span class="ruby-operator">:</span>        <span class="ruby-value">:numeric</span>,
                <span class="ruby-identifier">header_converters</span><span class="ruby-operator">:</span> <span class="ruby-value">:symbol</span> }.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">options</span>) )
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-3C-3C" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">&lt;&lt;</span><span
            class="method-args">(row)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The primary write method for wrapped Strings and IOs, <code>row</code> (an
Array or <a href="CSV/Row.html">CSV::Row</a>) is converted to <a
href="CSV.html">CSV</a> and appended to the data source.  When a <a
href="CSV/Row.html">CSV::Row</a> is passed, only the row&#39;s fields() are
appended to the output.</p>

<p>The data source must be open for writing.</p>
          
          

          
          <div class="method-source-code" id="3C-3C-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1686</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">&lt;&lt;</span>(<span class="ruby-identifier">row</span>)
  <span class="ruby-comment"># make sure headers have been assigned</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">header_row?</span> <span class="ruby-keyword">and</span> [<span class="ruby-constant">Array</span>, <span class="ruby-constant">String</span>].<span class="ruby-identifier">include?</span> <span class="ruby-ivar">@use_headers</span>.<span class="ruby-identifier">class</span>
    <span class="ruby-identifier">parse_headers</span>  <span class="ruby-comment"># won&#39;t read data for Array or String</span>
    <span class="ruby-keyword">self</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-ivar">@headers</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@write_headers</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># handle CSV::Row objects and Hashes</span>
  <span class="ruby-identifier">row</span> = <span class="ruby-keyword">case</span> <span class="ruby-identifier">row</span>
        <span class="ruby-keyword">when</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span><span class="ruby-operator">::</span><span class="ruby-constant">Row</span> <span class="ruby-keyword">then</span> <span class="ruby-identifier">row</span>.<span class="ruby-identifier">fields</span>
        <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>            <span class="ruby-keyword">then</span> <span class="ruby-ivar">@headers</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">header</span><span class="ruby-operator">|</span> <span class="ruby-identifier">row</span>[<span class="ruby-identifier">header</span>] }
        <span class="ruby-keyword">else</span>                      <span class="ruby-identifier">row</span>
        <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@headers</span> =  <span class="ruby-identifier">row</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">header_row?</span>
  <span class="ruby-ivar">@lineno</span>  <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>

  <span class="ruby-identifier">output</span> = <span class="ruby-identifier">row</span>.<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-ivar">@quote</span>).<span class="ruby-identifier">join</span>(<span class="ruby-ivar">@col_sep</span>) <span class="ruby-operator">+</span> <span class="ruby-ivar">@row_sep</span>  <span class="ruby-comment"># quote and separate</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">StringIO</span>)             <span class="ruby-keyword">and</span>
     <span class="ruby-identifier">output</span>.<span class="ruby-identifier">encoding</span> <span class="ruby-operator">!=</span> (<span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">raw_encoding</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@force_encoding</span>
      <span class="ruby-identifier">output</span> = <span class="ruby-identifier">output</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-identifier">encoding</span>)
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">compatible_encoding</span> = <span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">compatible?</span>(<span class="ruby-ivar">@io</span>.<span class="ruby-identifier">string</span>, <span class="ruby-identifier">output</span>))
      <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">set_encoding</span>(<span class="ruby-identifier">compatible_encoding</span>)
      <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">seek</span>(<span class="ruby-value">0</span>, <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">SEEK_END</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@io</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">output</span>

  <span class="ruby-keyword">self</span>  <span class="ruby-comment"># for chaining</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="CSV.html#method-i-add_row">add_row</a>, <a href="CSV.html#method-i-puts">puts</a>
        </div>
        

        
      </div>

    
      <div id="method-i-add_row" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">add_row</span><span
            class="method-args">(row)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="CSV.html#method-i-3C-3C">&lt;&lt;</a>
        </div>
        
      </div>

    
      <div id="method-i-convert" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            convert( name )
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            convert { |field| ... }
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            convert { |field, field_info| ... }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>You can use this method to install a <a
href="CSV.html#Converters">CSV::Converters</a> built-in, or provide a block
that handles a custom conversion.</p>

<p>If you provide a block that takes one argument, it will be passed the field
and is expected to return the converted value or the field itself.  If your
block takes two arguments, it will also be passed a <a
href="CSV.html#FieldInfo">CSV::FieldInfo</a> <a
href="Struct.html">Struct</a>, containing details about the field.  Again,
the block should return a converted field or the field itself.</p>
          
          

          
          <div class="method-source-code" id="convert-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1735</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">convert</span>(<span class="ruby-identifier">name</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">converter</span>)
  <span class="ruby-identifier">add_converter</span>(<span class="ruby-value">:converters</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span><span class="ruby-operator">::</span><span class="ruby-constant">Converters</span>, <span class="ruby-identifier">name</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">converter</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-converters" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">converters</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the current list of converters in effect.  See <a
href="CSV.html#method-c-new">::new</a> for details. Built-in converters
will be returned by name, while others will be returned as is.</p>
          
          

          
          <div class="method-source-code" id="converters-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1600</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">converters</span>
  <span class="ruby-ivar">@converters</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">converter</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">name</span> = <span class="ruby-constant">Converters</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-identifier">converter</span>)
    <span class="ruby-identifier">name</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">converter</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">each</span><span
            class="method-args">() { |row| ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Yields each row of the data source in turn.</p>

<p>Support for <a href="Enumerable.html">Enumerable</a>.</p>

<p>The data source must be open for reading.</p>
          
          

          
          <div class="method-source-code" id="each-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1766</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">while</span> <span class="ruby-identifier">row</span> = <span class="ruby-identifier">shift</span>
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">row</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">to_enum</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-force_quotes-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">force_quotes?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if all output fields are quoted. See <a
href="CSV.html#method-c-new">::new</a> for details.</p>
          
          

          
          <div class="method-source-code" id="force_quotes-3F-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1643</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">force_quotes?</span>()       <span class="ruby-ivar">@force_quotes</span>       <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-gets" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">gets</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="CSV.html#method-i-shift">shift</a>
        </div>
        
      </div>

    
      <div id="method-i-header_convert" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            header_convert( name )
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            header_convert { |field| ... }
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            header_convert { |field, field_info| ... }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Identical to <a href="CSV.html#method-i-convert">#convert</a>, but for
header rows.</p>

<p>Note that this method must be called before header rows are read to have
any effect.</p>
          
          

          
          <div class="method-source-code" id="header_convert-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1750</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">header_convert</span>(<span class="ruby-identifier">name</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">converter</span>)
  <span class="ruby-identifier">add_converter</span>( <span class="ruby-value">:header_converters</span>,
                 <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span><span class="ruby-operator">::</span><span class="ruby-constant">HeaderConverters</span>,
                 <span class="ruby-identifier">name</span>,
                 <span class="ruby-operator">&amp;</span><span class="ruby-identifier">converter</span> )
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-header_converters" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">header_converters</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the current list of converters in effect for headers.  See <a
href="CSV.html#method-c-new">::new</a> for details.  Built-in converters
will be returned by name, while others will be returned as is.</p>
          
          

          
          <div class="method-source-code" id="header_converters-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1631</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">header_converters</span>
  <span class="ruby-ivar">@header_converters</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">converter</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">name</span> = <span class="ruby-constant">HeaderConverters</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-identifier">converter</span>)
    <span class="ruby-identifier">name</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">converter</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-header_row-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">header_row?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the next row read will be a header row.</p>
          
          

          
          <div class="method-source-code" id="header_row-3F-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1792</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">header_row?</span>
  <span class="ruby-ivar">@use_headers</span> <span class="ruby-keyword">and</span> <span class="ruby-ivar">@headers</span>.<span class="ruby-identifier">nil?</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-headers" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">headers</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns <code>nil</code> if headers will not be used, <code>true</code> if
they will but have not yet been read, or the actual headers after they have
been read.  See <a href="CSV.html#method-c-new">::new</a> for details.</p>
          
          

          
          <div class="method-source-code" id="headers-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1616</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">headers</span>
  <span class="ruby-ivar">@headers</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@use_headers</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inspect" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inspect</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a simplified description of the key <a href="CSV.html">CSV</a>
attributes in an ASCII compatible String.</p>
          
          

          
          <div class="method-source-code" id="inspect-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1960</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inspect</span>
  <span class="ruby-identifier">str</span> = [<span class="ruby-node">&quot;&lt;#&quot;</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-string">&quot; io_type:&quot;</span>]
  <span class="ruby-comment"># show type of wrapped IO</span>
  <span class="ruby-keyword">if</span>    <span class="ruby-ivar">@io</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">$stdout</span> <span class="ruby-keyword">then</span> <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;$stdout&quot;</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@io</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">$stdin</span>  <span class="ruby-keyword">then</span> <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;$stdin&quot;</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@io</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">$stderr</span> <span class="ruby-keyword">then</span> <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;$stderr&quot;</span>
  <span class="ruby-keyword">else</span>                      <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">to_s</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># show IO.path(), if available</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:path</span>) <span class="ruby-keyword">and</span> (<span class="ruby-identifier">p</span> = <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">path</span>)
    <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot; io_path:&quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">inspect</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># show encoding</span>
  <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot; encoding:&quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-ivar">@encoding</span>.<span class="ruby-identifier">name</span>
  <span class="ruby-comment"># show other attributes</span>
  <span class="ruby-node">%w[ lineno     col_sep     row_sep
      quote_char skip_blanks liberal_parsing ]</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attr_name</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">a</span> = <span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-node">&quot;@#{attr_name}&quot;</span>)
      <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">attr_name</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;:&quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">inspect</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@use_headers</span>
    <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot; headers:&quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">headers</span>.<span class="ruby-identifier">inspect</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;&gt;&quot;</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">str</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;&#39;</span>)
  <span class="ruby-keyword">rescue</span>  <span class="ruby-comment"># any encoding error</span>
    <span class="ruby-identifier">str</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">e</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">asciicompat_encoding</span>(<span class="ruby-identifier">s</span>.<span class="ruby-identifier">encoding</span>)
      <span class="ruby-identifier">e</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-identifier">e</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;ASCII-8BIT&quot;</span>)
    <span class="ruby-keyword">end</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;&#39;</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-liberal_parsing-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">liberal_parsing?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if illegal input is handled. See <a
href="CSV.html#method-c-new">::new</a> for details.</p>
          
          

          
          <div class="method-source-code" id="liberal_parsing-3F-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1645</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">liberal_parsing?</span>()    <span class="ruby-ivar">@liberal_parsing</span>    <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-puts" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">puts</span><span
            class="method-args">(row)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="CSV.html#method-i-3C-3C">&lt;&lt;</a>
        </div>
        
      </div>

    
      <div id="method-i-read" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">read</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Slurps the remaining rows and returns an Array of Arrays.</p>

<p>The data source must be open for reading.</p>
          
          

          
          <div class="method-source-code" id="read-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1781</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">read</span>
  <span class="ruby-identifier">rows</span> = <span class="ruby-identifier">to_a</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@use_headers</span>
    <span class="ruby-constant">Table</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">rows</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">rows</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="CSV.html#method-i-readlines">readlines</a>
        </div>
        

        
      </div>

    
      <div id="method-i-readline" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">readline</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="CSV.html#method-i-shift">shift</a>
        </div>
        
      </div>

    
      <div id="method-i-readlines" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">readlines</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="CSV.html#method-i-read">read</a>
        </div>
        
      </div>

    
      <div id="method-i-return_headers-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">return_headers?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if headers will be returned as a row of results.
See <a href="CSV.html#method-c-new">::new</a> for details.</p>
          
          

          
          <div class="method-source-code" id="return_headers-3F-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1623</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">return_headers?</span>()     <span class="ruby-ivar">@return_headers</span>     <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rewind" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rewind</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Rewinds the underlying <a href="IO.html">IO</a> object and resets CSV&#39;s
lineno() counter.</p>
          
          

          
          <div class="method-source-code" id="rewind-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1670</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rewind</span>
  <span class="ruby-ivar">@headers</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@lineno</span>  = <span class="ruby-value">0</span>

  <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">rewind</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-shift" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">shift</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The primary read method for wrapped Strings and IOs, a single row is pulled
from the data source, parsed and returned as an Array of fields (if header
rows are not used) or a <a href="CSV/Row.html">CSV::Row</a> (when header
rows are used).</p>

<p>The data source must be open for reading.</p>
          
          

          
          <div class="method-source-code" id="shift-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1803</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">shift</span>
  <span class="ruby-comment">#########################################################################</span>
  <span class="ruby-comment">### This method is purposefully kept a bit long as simple conditional ###</span>
  <span class="ruby-comment">### checks are faster than numerous (expensive) method calls.         ###</span>
  <span class="ruby-comment">#########################################################################</span>

  <span class="ruby-comment"># handle headers not based on document content</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">header_row?</span> <span class="ruby-keyword">and</span> <span class="ruby-ivar">@return_headers</span> <span class="ruby-keyword">and</span>
     [<span class="ruby-constant">Array</span>, <span class="ruby-constant">String</span>].<span class="ruby-identifier">include?</span> <span class="ruby-ivar">@use_headers</span>.<span class="ruby-identifier">class</span>
    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@unconverted_fields</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">add_unconverted_fields</span>(<span class="ruby-identifier">parse_headers</span>, <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">parse_headers</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># it can take multiple calls to &lt;tt&gt;@io.gets()&lt;/tt&gt; to get a full line,</span>
  <span class="ruby-comment"># because of \r and/or \n characters embedded in quoted fields</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-identifier">in_extended_col</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-identifier">csv</span>             = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>

  <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># add another read to the line</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">parse</span> = <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">gets</span>(<span class="ruby-ivar">@row_sep</span>)
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">parse</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-ivar">@parsers</span>[<span class="ruby-value">:line_end</span>], <span class="ruby-string">&quot;&quot;</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-comment"># I believe a blank line should be an &lt;tt&gt;Array.new&lt;/tt&gt;, not Ruby 1.8</span>
      <span class="ruby-comment"># CSV&#39;s &lt;tt&gt;[nil]&lt;/tt&gt;</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parse</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-ivar">@lineno</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">if</span> <span class="ruby-ivar">@skip_blanks</span>
          <span class="ruby-keyword">next</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@unconverted_fields</span>
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">add_unconverted_fields</span>(<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>, <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>)
        <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@use_headers</span>
          <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span><span class="ruby-operator">::</span><span class="ruby-constant">Row</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>, <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">return</span> <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@skip_lines</span> <span class="ruby-keyword">and</span> <span class="ruby-ivar">@skip_lines</span>.<span class="ruby-identifier">match</span> <span class="ruby-identifier">parse</span>

    <span class="ruby-identifier">parts</span> =  <span class="ruby-identifier">parse</span>.<span class="ruby-identifier">split</span>(<span class="ruby-ivar">@col_sep</span>, <span class="ruby-value">-1</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">in_extended_col</span>
        <span class="ruby-identifier">csv</span>[<span class="ruby-value">-1</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-ivar">@col_sep</span>   <span class="ruby-comment"># will be replaced with a @row_sep after the parts.each loop</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">nil</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># This loop is the hot path of csv parsing. Some things may be non-dry</span>
    <span class="ruby-comment"># for a reason. Make sure to benchmark when refactoring.</span>
    <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">part</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">in_extended_col</span>
        <span class="ruby-comment"># If we are continuing a previous column</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">part</span>[<span class="ruby-value">-1</span>] <span class="ruby-operator">==</span> <span class="ruby-ivar">@quote_char</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">part</span>.<span class="ruby-identifier">count</span>(<span class="ruby-ivar">@quote_char</span>) <span class="ruby-operator">%</span> <span class="ruby-value">2</span> <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
          <span class="ruby-comment"># extended column ends</span>
          <span class="ruby-identifier">csv</span>[<span class="ruby-value">-1</span>] = <span class="ruby-identifier">csv</span>[<span class="ruby-value">-1</span>].<span class="ruby-identifier">push</span>(<span class="ruby-identifier">part</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>]).<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;&quot;</span>)
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">=~</span> <span class="ruby-ivar">@parsers</span>[<span class="ruby-value">:stray_quote</span>]
            <span class="ruby-identifier">raise</span> <span class="ruby-constant">MalformedCSVError</span>,
                  <span class="ruby-node">&quot;Missing or stray quote in line #{lineno + 1}&quot;</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-ivar">@quote_char</span> <span class="ruby-operator">*</span> <span class="ruby-value">2</span>, <span class="ruby-ivar">@quote_char</span>)
          <span class="ruby-identifier">in_extended_col</span> = <span class="ruby-keyword">false</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">part</span>, <span class="ruby-ivar">@col_sep</span>)
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">part</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-ivar">@quote_char</span>
        <span class="ruby-comment"># If we are starting a new quoted column</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">part</span>.<span class="ruby-identifier">count</span>(<span class="ruby-ivar">@quote_char</span>) <span class="ruby-operator">%</span> <span class="ruby-value">2</span> <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
          <span class="ruby-comment"># start an extended column</span>
          <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">part</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>], <span class="ruby-ivar">@col_sep</span>]
          <span class="ruby-identifier">in_extended_col</span> =  <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">part</span>[<span class="ruby-value">-1</span>] <span class="ruby-operator">==</span> <span class="ruby-ivar">@quote_char</span>
          <span class="ruby-comment"># regular quoted column</span>
          <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">part</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>]
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">=~</span> <span class="ruby-ivar">@parsers</span>[<span class="ruby-value">:stray_quote</span>]
            <span class="ruby-identifier">raise</span> <span class="ruby-constant">MalformedCSVError</span>,
                  <span class="ruby-node">&quot;Missing or stray quote in line #{lineno + 1}&quot;</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-ivar">@quote_char</span> <span class="ruby-operator">*</span> <span class="ruby-value">2</span>, <span class="ruby-ivar">@quote_char</span>)
        <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@liberal_parsing</span>
          <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">part</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">raise</span> <span class="ruby-constant">MalformedCSVError</span>,
                <span class="ruby-node">&quot;Missing or stray quote in line #{lineno + 1}&quot;</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">part</span> <span class="ruby-operator">=~</span> <span class="ruby-ivar">@parsers</span>[<span class="ruby-value">:quote_or_nl</span>]
        <span class="ruby-comment"># Unquoted field with bad characters.</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">part</span> <span class="ruby-operator">=~</span> <span class="ruby-ivar">@parsers</span>[<span class="ruby-value">:nl_or_lf</span>]
          <span class="ruby-identifier">raise</span> <span class="ruby-constant">MalformedCSVError</span>, <span class="ruby-string">&quot;Unquoted fields do not allow &quot;</span> <span class="ruby-operator">+</span>
                                   <span class="ruby-node">&quot;\\r or \\n (line #{lineno + 1}).&quot;</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">if</span> <span class="ruby-ivar">@liberal_parsing</span>
            <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">part</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-identifier">raise</span> <span class="ruby-constant">MalformedCSVError</span>, <span class="ruby-node">&quot;Illegal quoting in line #{lineno + 1}.&quot;</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># Regular ole unquoted field.</span>
        <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">part</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">part</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Replace tacked on @col_sep with @row_sep if we are still in an extended</span>
    <span class="ruby-comment"># column.</span>
    <span class="ruby-identifier">csv</span>[<span class="ruby-value">-1</span>][<span class="ruby-value">-1</span>] = <span class="ruby-ivar">@row_sep</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">in_extended_col</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">in_extended_col</span>
      <span class="ruby-comment"># if we&#39;re at eof?(), a quoted field wasn&#39;t closed...</span>
      <span class="ruby-keyword">if</span> <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">eof?</span>
        <span class="ruby-identifier">raise</span> <span class="ruby-constant">MalformedCSVError</span>,
              <span class="ruby-node">&quot;Unclosed quoted field on line #{lineno + 1}.&quot;</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@field_size_limit</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:size</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-ivar">@field_size_limit</span>
        <span class="ruby-identifier">raise</span> <span class="ruby-constant">MalformedCSVError</span>, <span class="ruby-node">&quot;Field size exceeded on line #{lineno + 1}.&quot;</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-comment"># otherwise, we need to loop and pull some more data to complete the row</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-ivar">@lineno</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>

      <span class="ruby-comment"># save fields unconverted fields, if needed...</span>
      <span class="ruby-identifier">unconverted</span> = <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">dup</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@unconverted_fields</span>

      <span class="ruby-comment"># convert fields, if needed...</span>
      <span class="ruby-identifier">csv</span> = <span class="ruby-identifier">convert_fields</span>(<span class="ruby-identifier">csv</span>) <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@use_headers</span> <span class="ruby-keyword">or</span> <span class="ruby-ivar">@converters</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-comment"># parse out header rows and handle CSV::Row conversions...</span>
      <span class="ruby-identifier">csv</span> = <span class="ruby-identifier">parse_headers</span>(<span class="ruby-identifier">csv</span>)  <span class="ruby-keyword">if</span>     <span class="ruby-ivar">@use_headers</span>

      <span class="ruby-comment"># inject unconverted fields and accessor, if requested...</span>
      <span class="ruby-keyword">if</span> <span class="ruby-ivar">@unconverted_fields</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">csv</span>.<span class="ruby-identifier">respond_to?</span> <span class="ruby-value">:unconverted_fields</span>
        <span class="ruby-identifier">add_unconverted_fields</span>(<span class="ruby-identifier">csv</span>, <span class="ruby-identifier">unconverted</span>)
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># return the results</span>
      <span class="ruby-keyword">break</span> <span class="ruby-identifier">csv</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="CSV.html#method-i-gets">gets</a>, <a href="CSV.html#method-i-readline">readline</a>
        </div>
        

        
      </div>

    
      <div id="method-i-skip_blanks-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">skip_blanks?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns <code>true</code> blank lines are skipped by the parser. See <a
href="CSV.html#method-c-new">::new</a> for details.</p>
          
          

          
          <div class="method-source-code" id="skip_blanks-3F-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1641</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">skip_blanks?</span>()        <span class="ruby-ivar">@skip_blanks</span>        <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-unconverted_fields-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">unconverted_fields?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if unconverted_fields() to parsed results.  See
<a href="CSV.html#method-c-new">::new</a> for details.</p>
          
          

          
          <div class="method-source-code" id="unconverted_fields-3F-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1610</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unconverted_fields?</span>() <span class="ruby-ivar">@unconverted_fields</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-write_headers-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write_headers?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if headers are written in output. See <a
href="CSV.html#method-c-new">::new</a> for details.</p>
          
          

          
          <div class="method-source-code" id="write_headers-3F-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 1625</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">write_headers?</span>()      <span class="ruby-ivar">@write_headers</span>      <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="private-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Private Instance Methods</h3>
       </header>

    
      <div id="method-i-add_converter" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_converter</span><span
            class="method-args">(var_name, const, name = nil, &converter)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The actual work method for adding converters, used by both <a
href="CSV.html#method-i-convert">#convert</a> and <a
href="CSV.html#method-i-header_convert">#header_convert</a>.</p>

<p>This method requires the <code>var_name</code> of the instance variable to
place the converters in, the <code>const</code> <a
href="Hash.html">Hash</a> to lookup named converters in, and the normal
parameters of the <a href="CSV.html#method-i-convert">#convert</a> and <a
href="CSV.html#method-i-header_convert">#header_convert</a> methods.</p>
          
          

          
          <div class="method-source-code" id="add_converter-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">add_converter</span>(<span class="ruby-identifier">var_name</span>, <span class="ruby-identifier">const</span>, <span class="ruby-identifier">name</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">converter</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">nil?</span>  <span class="ruby-comment"># custom converter</span>
    <span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-node">&quot;@#{var_name}&quot;</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">converter</span>
  <span class="ruby-keyword">else</span>          <span class="ruby-comment"># named converter</span>
    <span class="ruby-identifier">combo</span> = <span class="ruby-identifier">const</span>[<span class="ruby-identifier">name</span>]
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">combo</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Array</span>  <span class="ruby-comment"># combo converter</span>
      <span class="ruby-identifier">combo</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">converter_name</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">add_converter</span>(<span class="ruby-identifier">var_name</span>, <span class="ruby-identifier">const</span>, <span class="ruby-identifier">converter_name</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>        <span class="ruby-comment"># individual named converter</span>
      <span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-node">&quot;@#{var_name}&quot;</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">combo</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-add_unconverted_fields" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_unconverted_fields</span><span
            class="method-args">(row, fields)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This method injects an instance variable <code>unconverted_fields</code>
into <code>row</code> and an accessor method for <code>row</code> called
unconverted_fields().  The variable is set to the contents of
<code>fields</code>.</p>
          
          

          
          <div class="method-source-code" id="add_unconverted_fields-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2287</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">add_unconverted_fields</span>(<span class="ruby-identifier">row</span>, <span class="ruby-identifier">fields</span>)
  <span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">row</span>
    <span class="ruby-identifier">attr_reader</span> <span class="ruby-value">:unconverted_fields</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">row</span>.<span class="ruby-identifier">instance_eval</span> { <span class="ruby-ivar">@unconverted_fields</span> = <span class="ruby-identifier">fields</span> }
  <span class="ruby-identifier">row</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-convert_fields" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">convert_fields</span><span
            class="method-args">(fields, headers = false)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Processes <code>fields</code> with <code>@converters</code>, or
<code>@header_converters</code> if <code>headers</code> is passed as
<code>true</code>, returning the converted field set.  Any converter that
changes the field into something other than a String halts the pipeline of
conversion for that field.  This is primarily an efficiency shortcut.</p>
          
          

          
          <div class="method-source-code" id="convert_fields-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">convert_fields</span>(<span class="ruby-identifier">fields</span>, <span class="ruby-identifier">headers</span> = <span class="ruby-keyword">false</span>)
  <span class="ruby-comment"># see if we are converting headers or fields</span>
  <span class="ruby-identifier">converters</span> = <span class="ruby-identifier">headers</span> <span class="ruby-operator">?</span> <span class="ruby-ivar">@header_converters</span> <span class="ruby-operator">:</span> <span class="ruby-ivar">@converters</span>

  <span class="ruby-identifier">fields</span>.<span class="ruby-identifier">map</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">field</span>, <span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">converters</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">converter</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">field</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">field</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">converter</span>.<span class="ruby-identifier">arity</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>  <span class="ruby-comment"># straight field converter</span>
        <span class="ruby-identifier">converter</span>[<span class="ruby-identifier">field</span>]
      <span class="ruby-keyword">else</span>                             <span class="ruby-comment"># FieldInfo converter</span>
        <span class="ruby-identifier">header</span> = <span class="ruby-ivar">@use_headers</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">headers</span> <span class="ruby-operator">?</span> <span class="ruby-ivar">@headers</span>[<span class="ruby-identifier">index</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
        <span class="ruby-identifier">converter</span>[<span class="ruby-identifier">field</span>, <span class="ruby-constant">FieldInfo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">index</span>, <span class="ruby-identifier">lineno</span>, <span class="ruby-identifier">header</span>)]
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">break</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">field</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">String</span>  <span class="ruby-comment"># short-circuit pipeline for speed</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">field</span>  <span class="ruby-comment"># final state of each field, converted or original</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-encode_re" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">encode_re</span><span
            class="method-args">(*chunks)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Builds a regular expression in <code>@encoding</code>.  All
<code>chunks</code> will be transcoded to that encoding.</p>
          
          

          
          <div class="method-source-code" id="encode_re-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2310</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">encode_re</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">chunks</span>)
  <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">encode_str</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">chunks</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-encode_str" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">encode_str</span><span
            class="method-args">(*chunks)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Builds a String in <code>@encoding</code>.  All <code>chunks</code> will be
transcoded to that encoding.</p>
          
          

          
          <div class="method-source-code" id="encode_str-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2318</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">encode_str</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">chunks</span>)
  <span class="ruby-identifier">chunks</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">chunk</span><span class="ruby-operator">|</span> <span class="ruby-identifier">chunk</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-ivar">@encoding</span>.<span class="ruby-identifier">name</span>) }.<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;&#39;</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-escape_re" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">escape_re</span><span
            class="method-args">(str)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This method is an encoding safe version of <a
href="Regexp.html#method-c-escape">Regexp.escape</a>.  It will escape any
characters that would change the meaning of a regular expression in the
encoding of <code>str</code>.  Regular expression characters that cannot be
transcoded to the target encoding will be skipped and no escaping will be
performed if a backslash cannot be transcoded.</p>
          
          

          
          <div class="method-source-code" id="escape_re-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2302</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">escape_re</span>(<span class="ruby-identifier">str</span>)
  <span class="ruby-identifier">str</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-ivar">@re_chars</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-ivar">@re_esc</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">c</span>}
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-init_comments" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">init_comments</span><span
            class="method-args">(options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Stores the pattern of comments to skip from the provided options.</p>

<p>The pattern must respond to <code>.match</code>, else <a
href="ArgumentError.html">ArgumentError</a> is raised. Strings are
converted to a <a href="Regexp.html">Regexp</a>.</p>

<p>See also <a href="CSV.html#method-c-new">::new</a></p>
          
          

          
          <div class="method-source-code" id="init_comments-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">init_comments</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-ivar">@skip_lines</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:skip_lines</span>)
  <span class="ruby-ivar">@skip_lines</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-ivar">@skip_lines</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@skip_lines</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">String</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@skip_lines</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-ivar">@skip_lines</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:match</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;:skip_lines has to respond to matches&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-init_converters" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">init_converters</span><span
            class="method-args">(options, field_name = :converters)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Loads any converters requested during construction.</p>

<p>If <code>field_name</code> is set <code>:converters</code> (the default)
field converters are set.  When <code>field_name</code> is
<code>:header_converters</code> header converters are added instead.</p>

<p>The <code>:unconverted_fields</code> option is also activated for
<code>:converters</code> calls, if requested.</p>
          
          

          
          <div class="method-source-code" id="init_converters-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">init_converters</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">field_name</span> = <span class="ruby-value">:converters</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">field_name</span> <span class="ruby-operator">==</span> <span class="ruby-value">:converters</span>
    <span class="ruby-ivar">@unconverted_fields</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:unconverted_fields</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-node">&quot;@#{field_name}&quot;</span>, <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>)

  <span class="ruby-comment"># find the correct method to add the converters</span>
  <span class="ruby-identifier">convert</span> = <span class="ruby-identifier">method</span>(<span class="ruby-identifier">field_name</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-regexp">/ers\Z/</span>, <span class="ruby-string">&quot;&quot;</span>))

  <span class="ruby-comment"># load converters</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">field_name</span>].<span class="ruby-identifier">nil?</span>
    <span class="ruby-comment"># allow a single converter not wrapped in an Array</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">field_name</span>].<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Array</span>
      <span class="ruby-identifier">options</span>[<span class="ruby-identifier">field_name</span>] = [<span class="ruby-identifier">options</span>[<span class="ruby-identifier">field_name</span>]]
    <span class="ruby-keyword">end</span>
    <span class="ruby-comment"># load each converter...</span>
    <span class="ruby-identifier">options</span>[<span class="ruby-identifier">field_name</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">converter</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">converter</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Proc</span>  <span class="ruby-comment"># custom code block</span>
        <span class="ruby-identifier">convert</span>.<span class="ruby-identifier">call</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">converter</span>)
      <span class="ruby-keyword">else</span>                     <span class="ruby-comment"># by name</span>
        <span class="ruby-identifier">convert</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">converter</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">field_name</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-init_headers" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">init_headers</span><span
            class="method-args">(options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Stores header row settings and loads header converters, if needed.</p>
          
          

          
          <div class="method-source-code" id="init_headers-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">init_headers</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-ivar">@use_headers</span>    = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:headers</span>)
  <span class="ruby-ivar">@return_headers</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:return_headers</span>)
  <span class="ruby-ivar">@write_headers</span>  = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:write_headers</span>)

  <span class="ruby-comment"># headers must be delayed until shift(), in case they need a row of content</span>
  <span class="ruby-ivar">@headers</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-identifier">init_converters</span>(<span class="ruby-identifier">options</span>, <span class="ruby-value">:header_converters</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-init_parsers" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">init_parsers</span><span
            class="method-args">(options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Pre-compiles parsers and stores them by name for access during reads.</p>
          
          

          
          <div class="method-source-code" id="init_parsers-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">init_parsers</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-comment"># store the parser behaviors</span>
  <span class="ruby-ivar">@skip_blanks</span>      = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:skip_blanks</span>)
  <span class="ruby-ivar">@field_size_limit</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:field_size_limit</span>)
  <span class="ruby-ivar">@liberal_parsing</span>  = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:liberal_parsing</span>)

  <span class="ruby-comment"># prebuild Regexps for faster parsing</span>
  <span class="ruby-identifier">esc_row_sep</span> = <span class="ruby-identifier">escape_re</span>(<span class="ruby-ivar">@row_sep</span>)
  <span class="ruby-identifier">esc_quote</span>   = <span class="ruby-identifier">escape_re</span>(<span class="ruby-ivar">@quote_char</span>)
  <span class="ruby-ivar">@parsers</span> = {
    <span class="ruby-comment"># for detecting parse errors</span>
    <span class="ruby-identifier">quote_or_nl</span><span class="ruby-operator">:</span>    <span class="ruby-identifier">encode_re</span>(<span class="ruby-string">&quot;[&quot;</span>, <span class="ruby-identifier">esc_quote</span>, <span class="ruby-string">&quot;\r\n]&quot;</span>),
    <span class="ruby-identifier">nl_or_lf</span><span class="ruby-operator">:</span>       <span class="ruby-identifier">encode_re</span>(<span class="ruby-string">&quot;[\r\n]&quot;</span>),
    <span class="ruby-identifier">stray_quote</span><span class="ruby-operator">:</span>    <span class="ruby-identifier">encode_re</span>( <span class="ruby-string">&quot;[^&quot;</span>, <span class="ruby-identifier">esc_quote</span>, <span class="ruby-string">&quot;]&quot;</span>, <span class="ruby-identifier">esc_quote</span>,
                               <span class="ruby-string">&quot;[^&quot;</span>, <span class="ruby-identifier">esc_quote</span>, <span class="ruby-string">&quot;]&quot;</span> ),
    <span class="ruby-comment"># safer than chomp!()</span>
    <span class="ruby-identifier">line_end</span><span class="ruby-operator">:</span>       <span class="ruby-identifier">encode_re</span>(<span class="ruby-identifier">esc_row_sep</span>, <span class="ruby-string">&quot;\\z&quot;</span>),
    <span class="ruby-comment"># illegal unquoted characters</span>
    <span class="ruby-identifier">return_newline</span><span class="ruby-operator">:</span> <span class="ruby-identifier">encode_str</span>(<span class="ruby-string">&quot;\r\n&quot;</span>)
  }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-init_separators" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">init_separators</span><span
            class="method-args">(options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Stores the indicated separators for later use.</p>

<p>If auto-discovery was requested for <code>@row_sep</code>, this method will
read ahead in the <code>@io</code> and try to find one.  <code>ARGF</code>,
<code>STDIN</code>, <code>STDOUT</code>, <code>STDERR</code> and any stream
open for output only with a default <code>@row_sep</code> of
<code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>).</p>

<p>This method also establishes the quoting rules used for <a
href="CSV.html">CSV</a> output.</p>
          
          

          
          <div class="method-source-code" id="init_separators-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2007</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">init_separators</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-comment"># store the selected separators</span>
  <span class="ruby-ivar">@col_sep</span>    = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:col_sep</span>).<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-ivar">@encoding</span>)
  <span class="ruby-ivar">@row_sep</span>    = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:row_sep</span>)  <span class="ruby-comment"># encode after resolving :auto</span>
  <span class="ruby-ivar">@quote_char</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:quote_char</span>).<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-ivar">@encoding</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@quote_char</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">!=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;:quote_char has to be a single character String&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># automatically discover row separator when requested</span>
  <span class="ruby-comment"># (not fully encoding safe)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@row_sep</span> <span class="ruby-operator">==</span> <span class="ruby-value">:auto</span>
    <span class="ruby-keyword">if</span> [<span class="ruby-constant">ARGF</span>, <span class="ruby-constant">STDIN</span>, <span class="ruby-constant">STDOUT</span>, <span class="ruby-constant">STDERR</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-ivar">@io</span>) <span class="ruby-keyword">or</span>
       (<span class="ruby-keyword">defined?</span>(<span class="ruby-constant">Zlib</span>) <span class="ruby-keyword">and</span> <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Zlib</span><span class="ruby-operator">::</span><span class="ruby-constant">GzipWriter</span>)
      <span class="ruby-ivar">@row_sep</span> = <span class="ruby-identifier">$INPUT_RECORD_SEPARATOR</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">begin</span>
        <span class="ruby-comment">#</span>
        <span class="ruby-comment"># remember where we were (pos() will raise an exception if @io is pipe</span>
        <span class="ruby-comment"># or not opened for reading)</span>
        <span class="ruby-comment">#</span>
        <span class="ruby-identifier">saved_pos</span> = <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">pos</span>
        <span class="ruby-keyword">while</span> <span class="ruby-ivar">@row_sep</span> <span class="ruby-operator">==</span> <span class="ruby-value">:auto</span>
          <span class="ruby-comment">#</span>
          <span class="ruby-comment"># if we run out of data, it&#39;s probably a single line</span>
          <span class="ruby-comment"># (ensure will set default value)</span>
          <span class="ruby-comment">#</span>
          <span class="ruby-keyword">break</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">sample</span> = <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">gets</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-value">1024</span>)
          <span class="ruby-comment"># extend sample if we&#39;re unsure of the line ending</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">sample</span>.<span class="ruby-identifier">end_with?</span> <span class="ruby-identifier">encode_str</span>(<span class="ruby-string">&quot;\r&quot;</span>)
            <span class="ruby-identifier">sample</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-ivar">@io</span>.<span class="ruby-identifier">gets</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>) <span class="ruby-operator">||</span> <span class="ruby-string">&quot;&quot;</span>)
          <span class="ruby-keyword">end</span>

          <span class="ruby-comment"># try to find a standard separator</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">sample</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">encode_re</span>(<span class="ruby-string">&quot;\r\n?|\n&quot;</span>)
            <span class="ruby-ivar">@row_sep</span> = <span class="ruby-node">$&amp;</span>
            <span class="ruby-keyword">break</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># tricky seek() clone to work around GzipReader&#39;s lack of seek()</span>
        <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">rewind</span>
        <span class="ruby-comment"># reset back to the remembered position</span>
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">saved_pos</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1024</span>  <span class="ruby-comment"># avoid loading a lot of data into memory</span>
          <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">1024</span>)
          <span class="ruby-identifier">saved_pos</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1024</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">read</span>(<span class="ruby-identifier">saved_pos</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">saved_pos</span>.<span class="ruby-identifier">nonzero?</span>
      <span class="ruby-keyword">rescue</span> <span class="ruby-constant">IOError</span>         <span class="ruby-comment"># not opened for reading</span>
        <span class="ruby-comment"># do nothing:  ensure will set default</span>
      <span class="ruby-keyword">rescue</span> <span class="ruby-constant">NoMethodError</span>   <span class="ruby-comment"># Zlib::GzipWriter doesn&#39;t have some IO methods</span>
        <span class="ruby-comment"># do nothing:  ensure will set default</span>
      <span class="ruby-keyword">rescue</span> <span class="ruby-constant">SystemCallError</span> <span class="ruby-comment"># pipe</span>
        <span class="ruby-comment"># do nothing:  ensure will set default</span>
      <span class="ruby-keyword">ensure</span>
        <span class="ruby-comment">#</span>
        <span class="ruby-comment"># set default if we failed to detect</span>
        <span class="ruby-comment"># (stream not opened for reading, a pipe, or a single line of data)</span>
        <span class="ruby-comment">#</span>
        <span class="ruby-ivar">@row_sep</span> = <span class="ruby-identifier">$INPUT_RECORD_SEPARATOR</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@row_sep</span> <span class="ruby-operator">==</span> <span class="ruby-value">:auto</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@row_sep</span> = <span class="ruby-ivar">@row_sep</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-ivar">@encoding</span>)

  <span class="ruby-comment"># establish quoting rules</span>
  <span class="ruby-ivar">@force_quotes</span>   = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:force_quotes</span>)
  <span class="ruby-identifier">do_quote</span>        = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">field</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">field</span>         = <span class="ruby-constant">String</span>(<span class="ruby-identifier">field</span>)
    <span class="ruby-identifier">encoded_quote</span> = <span class="ruby-ivar">@quote_char</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-identifier">field</span>.<span class="ruby-identifier">encoding</span>)
    <span class="ruby-identifier">encoded_quote</span>                                <span class="ruby-operator">+</span>
    <span class="ruby-identifier">field</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-identifier">encoded_quote</span>, <span class="ruby-identifier">encoded_quote</span> <span class="ruby-operator">*</span> <span class="ruby-value">2</span>) <span class="ruby-operator">+</span>
    <span class="ruby-identifier">encoded_quote</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">quotable_chars</span> = <span class="ruby-identifier">encode_str</span>(<span class="ruby-string">&quot;\r\n&quot;</span>, <span class="ruby-ivar">@col_sep</span>, <span class="ruby-ivar">@quote_char</span>)
  <span class="ruby-ivar">@quote</span>         = <span class="ruby-keyword">if</span> <span class="ruby-ivar">@force_quotes</span>
    <span class="ruby-identifier">do_quote</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">field</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">field</span>.<span class="ruby-identifier">nil?</span>  <span class="ruby-comment"># represent +nil+ fields as empty unquoted fields</span>
        <span class="ruby-string">&quot;&quot;</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">field</span> = <span class="ruby-constant">String</span>(<span class="ruby-identifier">field</span>)  <span class="ruby-comment"># Stringify fields</span>
        <span class="ruby-comment"># represent empty fields as empty quoted fields</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">field</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword">or</span>
           <span class="ruby-identifier">field</span>.<span class="ruby-identifier">count</span>(<span class="ruby-identifier">quotable_chars</span>).<span class="ruby-identifier">nonzero?</span>
          <span class="ruby-identifier">do_quote</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">field</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">field</span>  <span class="ruby-comment"># unquoted field</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-parse_headers" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_headers</span><span
            class="method-args">(row = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This method is used to turn a finished <code>row</code> into a <a
href="CSV/Row.html">CSV::Row</a>.  Header rows are also dealt with here,
either by returning a <a href="CSV/Row.html">CSV::Row</a> with identical
headers and fields (save that the fields do not go through the converters)
or by reading past them to return a field row. Headers are also saved in
<code>@headers</code> for use in future rows.</p>

<p>When <code>nil</code>, <code>row</code> is assumed to be a header row not
based on an actual row of the stream.</p>
          
          

          
          <div class="method-source-code" id="parse_headers-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">parse_headers</span>(<span class="ruby-identifier">row</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@headers</span>.<span class="ruby-identifier">nil?</span>                <span class="ruby-comment"># header row</span>
    <span class="ruby-ivar">@headers</span> = <span class="ruby-keyword">case</span> <span class="ruby-ivar">@use_headers</span>  <span class="ruby-comment"># save headers</span>
               <span class="ruby-comment"># Array of headers</span>
               <span class="ruby-keyword">when</span> <span class="ruby-constant">Array</span> <span class="ruby-keyword">then</span> <span class="ruby-ivar">@use_headers</span>
               <span class="ruby-comment"># CSV header String</span>
               <span class="ruby-keyword">when</span> <span class="ruby-constant">String</span>
                 <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">parse_line</span>( <span class="ruby-ivar">@use_headers</span>,
                                        <span class="ruby-identifier">col_sep</span><span class="ruby-operator">:</span>    <span class="ruby-ivar">@col_sep</span>,
                                        <span class="ruby-identifier">row_sep</span><span class="ruby-operator">:</span>    <span class="ruby-ivar">@row_sep</span>,
                                        <span class="ruby-identifier">quote_char</span><span class="ruby-operator">:</span> <span class="ruby-ivar">@quote_char</span> )
               <span class="ruby-comment"># first row is headers</span>
               <span class="ruby-keyword">else</span>            <span class="ruby-identifier">row</span>
               <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># prepare converted and unconverted copies</span>
    <span class="ruby-identifier">row</span>      = <span class="ruby-ivar">@headers</span>                       <span class="ruby-keyword">if</span> <span class="ruby-identifier">row</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-ivar">@headers</span> = <span class="ruby-identifier">convert_fields</span>(<span class="ruby-ivar">@headers</span>, <span class="ruby-keyword">true</span>)
    <span class="ruby-ivar">@headers</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">h</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>.<span class="ruby-identifier">freeze</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">h</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">String</span> }

    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@return_headers</span>                                     <span class="ruby-comment"># return headers</span>
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span><span class="ruby-operator">::</span><span class="ruby-constant">Row</span>.<span class="ruby-identifier">new</span>(<span class="ruby-ivar">@headers</span>, <span class="ruby-identifier">row</span>, <span class="ruby-keyword">true</span>)
    <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">not</span> [<span class="ruby-constant">Array</span>, <span class="ruby-constant">String</span>].<span class="ruby-identifier">include?</span> <span class="ruby-ivar">@use_headers</span>.<span class="ruby-identifier">class</span>  <span class="ruby-comment"># skip to field row</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">shift</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span><span class="ruby-operator">::</span><span class="ruby-constant">Row</span>.<span class="ruby-identifier">new</span>(<span class="ruby-ivar">@headers</span>, <span class="ruby-identifier">convert_fields</span>(<span class="ruby-identifier">row</span>))  <span class="ruby-comment"># field row</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-raw_encoding" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">raw_encoding</span><span
            class="method-args">(default = Encoding::ASCII_8BIT)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the encoding of the internal <a href="IO.html">IO</a> object or the
<code>default</code> if the encoding cannot be determined.</p>
          
          

          
          <div class="method-source-code" id="raw_encoding-source">
            <pre><span class="ruby-comment"># File lib/csv.rb, line 2328</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">raw_encoding</span>(<span class="ruby-identifier">default</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">ASCII_8BIT</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">respond_to?</span> <span class="ruby-value">:internal_encoding</span>
    <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">internal_encoding</span> <span class="ruby-operator">||</span> <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">external_encoding</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">StringIO</span>
    <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">string</span>.<span class="ruby-identifier">encoding</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">respond_to?</span> <span class="ruby-value">:encoding</span>
    <span class="ruby-ivar">@io</span>.<span class="ruby-identifier">encoding</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">default</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

